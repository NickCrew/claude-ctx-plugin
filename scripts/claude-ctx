#!/bin/bash

# Claude Context Manager
# Dynamically activate/deactivate modes and agents to optimize token usage
# Scenario orchestration helpers extend the base CLI.

CLAUDE_DIR="${CLAUDE_CTX_HOME:-${CLAUDE_PLUGIN_ROOT:-$HOME/.claude}}"
MODES_DIR="$CLAUDE_DIR/modes"
AGENTS_DIR="$CLAUDE_DIR/agents"
RULES_DIR="$CLAUDE_DIR/rules"
WORKFLOWS_DIR="$CLAUDE_DIR/workflows"
TASKS_DIR="$CLAUDE_DIR/tasks"
COMMANDS_DIR="$CLAUDE_DIR/commands"
SCENARIOS_DIR="$CLAUDE_DIR/scenarios"
SCENARIO_SCHEMA="$CLAUDE_DIR/schema/scenario-schema-v1.yaml"
SCENARIO_STATE_DIR="$SCENARIOS_DIR/.state"
SCENARIO_LOCK_DIR="$SCENARIOS_DIR/.locks"
INIT_STATE_DIR="$CLAUDE_DIR/.init"
INIT_PROJECTS_DIR="$INIT_STATE_DIR/projects"
INIT_CACHE_DIR="$INIT_STATE_DIR/cache"
CLAUDE_MD="$CLAUDE_DIR/CLAUDE.md"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

ACTIVATION_STACK=""

normalize_agent_filename() {
    local name="$1"
    if [[ -z "$name" ]]; then
        return 1
    fi
    if [[ "$name" != *.md ]]; then
        name="${name}.md"
    fi
    echo "$name"
}

agent_basename() {
    local name="$1"
    name=$(basename "$name")
    name="${name%.md}"
    echo "$name"
}

find_disabled_agent_file() {
    local filename
    filename=$(normalize_agent_filename "$1") || return 1

    if [[ -f "$CLAUDE_DIR/agents-disabled/$filename" ]]; then
        echo "$CLAUDE_DIR/agents-disabled/$filename"
        return 0
    fi

    if [[ -f "$AGENTS_DIR/disabled/$filename" ]]; then
        echo "$AGENTS_DIR/disabled/$filename"
        return 0
    fi

    return 1
}

find_agent_file_any_state() {
    local filename
    filename=$(normalize_agent_filename "$1") || return 1

    if [[ -f "$AGENTS_DIR/$filename" ]]; then
        echo "$AGENTS_DIR/$filename"
        return 0
    fi

    if [[ -f "$CLAUDE_DIR/agents-disabled/$filename" ]]; then
        echo "$CLAUDE_DIR/agents-disabled/$filename"
        return 0
    fi

    if [[ -f "$AGENTS_DIR/disabled/$filename" ]]; then
        echo "$AGENTS_DIR/disabled/$filename"
        return 0
    fi

    return 1
}

read_agent_dependencies() {
    local agent_path="$1"
    python3 - "$agent_path" <<'PY'
import sys
from pathlib import Path

import yaml

path = Path(sys.argv[1])
try:
    text = path.read_text(encoding="utf-8")
except FileNotFoundError:
    sys.exit(0)

text = text.lstrip()
if not text.startswith('---'):
    sys.exit(0)

parts = text.split('---', 2)
if len(parts) < 3:
    sys.exit(0)

try:
    metadata = yaml.safe_load(parts[1]) or {}
except yaml.YAMLError:
    sys.exit(0)

deps = metadata.get('dependencies') or {}
requires = deps.get('requires') or []
recommends = deps.get('recommends') or []

print('--REQUIRES--')
for item in requires:
    if isinstance(item, str) and item.strip():
        print(item.strip())

print('--RECOMMENDS--')
for item in recommends:
    if isinstance(item, str) and item.strip():
        print(item.strip())
PY
}

generate_dependency_map() {
    local map_output
    map_output=$(python3 - "$AGENTS_DIR" "$CLAUDE_DIR/agents-disabled" <<'PY'
import sys
from pathlib import Path

import yaml

active_dir = Path(sys.argv[1])
disabled_dir = Path(sys.argv[2])

def parse_agent(path):
    try:
        text = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        return None
    text = text.lstrip()
    if not text.startswith('---'):
        return None
    parts = text.split('---', 2)
    if len(parts) < 3:
        return None
    try:
        metadata = yaml.safe_load(parts[1]) or {}
    except yaml.YAMLError:
        return None
    if str(metadata.get('version')) != '2.0':
        return None
    name = metadata.get('name') or path.stem
    deps = metadata.get('dependencies') or {}
    requires = ','.join(item for item in (deps.get('requires') or []) if item)
    recommends = ','.join(item for item in (deps.get('recommends') or []) if item)
    return f"{name}:{requires}:{recommends}"

lines = ["# Auto-generated by claude-ctx", "# Format: agent:requires:recommends"]

if active_dir.exists():
    for path in sorted(active_dir.glob('*.md')):
        entry = parse_agent(path)
        if entry:
            lines.append(entry)

if disabled_dir.exists():
    for path in sorted(disabled_dir.glob('*.md')):
        entry = parse_agent(path)
        if entry:
            lines.append(entry)

print('\n'.join(lines))
PY
)
    local status=$?
    if [[ $status -ne 0 ]]; then
        return $status
    fi
    printf "%s\n" "$map_output" > "$AGENTS_DIR/dependencies.map"
}

collect_missing_recommends() {
    python3 - "$AGENTS_DIR" "$CLAUDE_DIR/agents-disabled" <<'PY'
import sys
from pathlib import Path

import yaml

active_dir = Path(sys.argv[1])
disabled_dir = Path(sys.argv[2])

active = {}
if active_dir.exists():
    for path in active_dir.glob('*.md'):
        if path.name.startswith('.'):  # skip hidden
            continue
        active[path.stem] = path

disabled = set()
if disabled_dir.exists():
    for path in disabled_dir.glob('*.md'):
        disabled.add(path.stem)

def metadata_for(path):
    try:
        text = path.read_text(encoding='utf-8')
    except FileNotFoundError:
        return None
    text = text.lstrip()
    if not text.startswith('---'):
        return None
    parts = text.split('---', 2)
    if len(parts) < 3:
        return None
    try:
        metadata = yaml.safe_load(parts[1]) or {}
    except yaml.YAMLError:
        return None
    if str(metadata.get('version')) != '2.0':
        return None
    return metadata

missing = {}

for name, path in active.items():
    metadata = metadata_for(path)
    if not metadata:
        continue
    deps = metadata.get('dependencies') or {}
    recommends = deps.get('recommends') or []
    for rec in recommends:
        if not rec:
            continue
        rec_name = Path(rec).stem
        if rec_name in active:
            continue
        status = 'disabled' if rec_name in disabled else 'missing'
        missing.setdefault(rec_name, status)

for name in sorted(missing):
    print(f"{name} ({missing[name]})")
PY
}

ensure_scenarios_dir() {
    mkdir -p "$SCENARIOS_DIR" "$SCENARIO_STATE_DIR" "$SCENARIO_LOCK_DIR"
    if [[ ! -f "$SCENARIOS_DIR/README.md" ]]; then
        cat > "$SCENARIOS_DIR/README.md" <<'EOF'
# Scenario definitions control orchestrated agent activation.
# Add YAML files here to describe phases, agents, and profiles for a workflow.
EOF
    fi
}

scenario_init_state() {
    local state_file="$1"
    local scenario_name="$2"
    local description="$3"
    local source_file="$4"
    local payload
    payload=$(python3 - "$scenario_name" "$description" "$source_file" <<'PY'
import json
import sys
from datetime import datetime

scenario_name, description, source_file = sys.argv[1:4]
data = {
    "scenario": scenario_name,
    "description": description,
    "source": source_file,
    "started": datetime.utcnow().isoformat() + "Z",
    "status": "running",
    "phases": []
}
print(json.dumps(data, indent=2))
PY
)
    printf '%s\n' "$payload" > "$state_file"
}

scenario_update_phase_state() {
    local state_file="$1"
    local phase_name="$2"
    local phase_idx="$3"
    local phase_status="$4"
    local note="$5"
    local current=""
    if [[ -f "$state_file" ]]; then
        current=$(cat "$state_file")
    fi
    local payload
    payload=$(python3 - "$phase_name" "$phase_idx" "$phase_status" "$note" <<'PY'
import json
import sys
from datetime import datetime

phase_name, phase_idx, phase_status, note = sys.argv[1:5]
phase_idx = int(phase_idx)

raw = sys.stdin.read()
data = json.loads(raw) if raw.strip() else {}
phases = data.setdefault('phases', [])
while len(phases) <= phase_idx:
    phases.append({"name": None})

entry = phases[phase_idx] or {}
entry.update({
    "name": phase_name,
    "status": phase_status,
    "updated": datetime.utcnow().isoformat() + "Z"
})
if note:
    entry['note'] = note
phases[phase_idx] = entry

print(json.dumps(data, indent=2))
PY
    ) <<< "$current"
    printf '%s\n' "$payload" > "$state_file"
}

scenario_finalize_state() {
    local state_file="$1"
    local final_status="$2"
    local current=""
    if [[ -f "$state_file" ]]; then
        current=$(cat "$state_file")
    fi
    local payload
    payload=$(python3 - "$final_status" <<'PY'
import json
import sys
from datetime import datetime

final_status = sys.argv[1]
raw = sys.stdin.read()
data = json.loads(raw) if raw.strip() else {}
data['status'] = final_status
data['completed'] = datetime.utcnow().isoformat() + "Z"

print(json.dumps(data, indent=2))
PY
    ) <<< "$current"
    printf '%s\n' "$payload" > "$state_file"
}

# ---------------------------------------------------------------------------
# Init helpers (state/cache scaffolding)
# ---------------------------------------------------------------------------

ensure_init_dirs() {
    mkdir -p "$INIT_STATE_DIR" "$INIT_PROJECTS_DIR" "$INIT_CACHE_DIR"
}

init_slug_for_path() {
    local target_path="$1"
    if [[ -z "$target_path" ]]; then
        target_path="$(pwd)"
    fi
    python3 - "$target_path" <<'PY'
import hashlib
import os
import sys
import unicodedata

path = os.path.abspath(sys.argv[1])
hash_part = hashlib.sha1(path.encode('utf-8')).hexdigest()[:12]
basename = os.path.basename(path) or "root"

normalized = unicodedata.normalize('NFKD', basename)
ascii_name = normalized.encode('ascii', 'ignore').decode('ascii')
safe = ''.join(c.lower() if c.isalnum() else '-' for c in ascii_name)
safe = safe.strip('-')
if not safe:
    safe = 'project'
safe = safe[:40]

slug = f"{safe}-{hash_part}"
print(slug)
PY
}

init_project_state_dir() {
    local slug
    slug=$(init_slug_for_path "$1")
    printf '%s\n' "$INIT_PROJECTS_DIR/$slug"
}

init_project_cache_dir() {
    local slug
    slug=$(init_slug_for_path "$1")
    printf '%s\n' "$INIT_CACHE_DIR/$slug"
}

init_wizard() {
    ensure_init_dirs
    local slug
    slug=$(init_slug_for_path "$PWD")
    echo -e "${YELLOW}TODO:${NC} init_wizard for project '$slug' not yet implemented."
}

init_detect() {
    ensure_init_dirs

    local target_path="${1:-$PWD}"
    if [[ ! -d "$target_path" ]]; then
        echo -e "${RED}init_detect:${NC} directory not found: $target_path"
        return 1
    fi

    local abs_path
    abs_path=$(cd "$target_path" 2>/dev/null && pwd)
    if [[ -z "$abs_path" ]]; then
        echo -e "${RED}init_detect:${NC} unable to resolve path: $target_path"
        return 1
    fi

    local slug
    slug=$(init_slug_for_path "$abs_path")

    local state_dir="$INIT_PROJECTS_DIR/$slug"
    local cache_dir="$INIT_CACHE_DIR/$slug"
    mkdir -p "$state_dir" "$cache_dir"

    local detection_json_cache="$cache_dir/detection.json"
    local detection_json_state="$state_dir/detection.json"
    local session_log_cache="$cache_dir/session-log.md"
    local session_log_state="$state_dir/session-log.md"

    local iso_now
    iso_now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    local detection_raw=""
    detection_raw=$(cd "$abs_path" && detect_project_type 2>/dev/null || true)

    local detection_language=""
    local detection_framework=""
    local detection_infra=""
    local detection_types=""
    if [[ -n "$detection_raw" ]]; then
        IFS='|' read -r detection_language detection_framework detection_infra detection_types <<< "$detection_raw"
    fi

    local analysis_raw=""
    analysis_raw=$(cd "$abs_path" && analyze_project 2>/dev/null || true)
    local analysis_plain
    analysis_plain=$(printf '%s\n' "$analysis_raw" | sed -E 's/\x1B\[[0-9;]*[A-Za-z]//g')

    local detection_payload
    detection_payload=$(ABS_PATH="$abs_path" SLUG="$slug" ISO_NOW="$iso_now" \
        DETECT_LANGUAGE="$detection_language" DETECT_FRAMEWORK="$detection_framework" \
        DETECT_INFRASTRUCTURE="$detection_infra" DETECT_TYPES="$detection_types" \
        ANALYSIS_TEXT="$analysis_plain" python3 - <<'PY'
import json
import os

types_raw = os.environ.get("DETECT_TYPES", "")
types = [item for item in types_raw.split() if item]

payload = {
    "path": os.environ.get("ABS_PATH", ""),
    "slug": os.environ.get("SLUG", ""),
    "timestamp": os.environ.get("ISO_NOW", ""),
    "language": os.environ.get("DETECT_LANGUAGE") or None,
    "framework": os.environ.get("DETECT_FRAMEWORK") or None,
    "infrastructure": os.environ.get("DETECT_INFRASTRUCTURE") or None,
    "types": types,
}

analysis_text = os.environ.get("ANALYSIS_TEXT", "").strip()
if analysis_text:
    payload["analysis_output"] = analysis_text

print(json.dumps(payload, indent=2, ensure_ascii=False))
PY
    )

    printf '%s\n' "$detection_payload" > "$detection_json_cache"
    printf '%s\n' "$detection_payload" > "$detection_json_state"

    {
        echo "# Init Detection Session"
        echo "- Timestamp: $iso_now"
        echo "- Path: $abs_path"
        echo "- Slug: $slug"
        echo ""
        echo "## Detection Summary"
        if [[ -n "$detection_language" ]]; then
            echo "- Language: $detection_language"
        fi
        if [[ -n "$detection_framework" ]]; then
            echo "- Framework: $detection_framework"
        fi
        if [[ -n "$detection_infra" ]]; then
            echo "- Infrastructure: $detection_infra"
        fi
        if [[ -n "$detection_types" ]]; then
            echo "- Types: $detection_types"
        fi
        if [[ -n "$analysis_plain" ]]; then
            echo ""
            echo "## analyze_project Output"
            printf '%s\n' "$analysis_plain"
        fi
    } > "$session_log_state"

    cp "$session_log_state" "$session_log_cache"

    echo -e "${GREEN}init_detect complete${NC}"
    echo -e "  Project path: ${BLUE}$abs_path${NC}"
    echo -e "  Project slug: ${BLUE}$slug${NC}"
    echo -e "  Detection JSON: ${BLUE}$detection_json_cache${NC}"
    echo -e "  Session log: ${BLUE}$session_log_state${NC}"
}

init_minimal() {
    ensure_init_dirs
    profile_reset
    echo -e "${GREEN}Initialized minimal claude-ctx configuration${NC}"
}

init_profile() {
    ensure_init_dirs
    local profile_name="$1"
    if [[ -z "$profile_name" ]]; then
        echo -e "${RED}init_profile requires a profile name${NC}"
        echo "Use 'claude-ctx profile list' to view available presets."
    else
        if profile_load "$profile_name"; then
            echo -e "${GREEN}Initialized claude-ctx with profile '${profile_name}'${NC}"
        else
            echo -e "${RED}Failed to load profile '${profile_name}'${NC}"
            return 1
        fi
    fi
}

init_status() {
    ensure_init_dirs
    local output_json=0
    local target_arg=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                output_json=1
                ;;
            *)
                if [[ -z "$target_arg" ]]; then
                    target_arg="$1"
                else
                    echo -e "${YELLOW}init_status:${NC} ignoring extra argument '$1'"
                fi
                ;;
        esac
        shift
    done

    local resolved_path=""
    local slug=""

    if [[ -n "$target_arg" && -d "$target_arg" ]]; then
        resolved_path=$(cd "$target_arg" 2>/dev/null && pwd)
        if [[ -z "$resolved_path" ]]; then
            echo -e "${RED}init_status:${NC} unable to resolve path: $target_arg"
            return 1
        fi
        slug=$(init_slug_for_path "$resolved_path")
    elif [[ -n "$target_arg" && ! -d "$target_arg" ]]; then
        slug="$target_arg"
    else
        resolved_path=$(pwd)
        slug=$(init_slug_for_path "$resolved_path")
    fi

    if [[ -z "$slug" ]]; then
        echo -e "${RED}init_status:${NC} unable to determine project slug."
        return 1
    fi

    local project_file="$INIT_PROJECTS_DIR/$slug/detection.json"
    local cache_file="$INIT_CACHE_DIR/$slug/detection.json"

    local mode="summary"
    [[ $output_json -eq 1 ]] && mode="json"

    python3 - "$mode" "$project_file" "$cache_file" "$slug" "${resolved_path:-}" \
        "$RED" "$GREEN" "$YELLOW" "$BLUE" "$NC" <<'PY'
import json
import os
import sys
from pathlib import Path

mode, project_file, cache_file, slug, resolved_path, red, green, yellow, blue, nc = sys.argv[1:11]

project_path = Path(os.path.expanduser(project_file))
cache_path = Path(os.path.expanduser(cache_file))

def load(path: Path):
    try:
        text = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        return None, "missing", None
    except OSError as exc:
        return None, f"error reading file: {exc}", None
    try:
        data = json.loads(text)
    except json.JSONDecodeError as exc:
        return None, f"invalid JSON: {exc}", text
    return data, None, text

proj_data, proj_error, proj_text = load(project_path)
cache_data, cache_error, cache_text = load(cache_path)

if proj_data is not None and cache_data is not None:
    match_status = "identical" if proj_data == cache_data else "mismatch"
else:
    match_status = "unverified"

base_data = proj_data or cache_data or {}

summary_path = base_data.get("path") or resolved_path or "(unknown)"
summary_slug = base_data.get("slug") or slug or "(unknown)"
summary_timestamp = base_data.get("timestamp") or "unknown"
summary_language = base_data.get("language") or "unknown"
summary_framework = base_data.get("framework") or "unknown"
summary_infra = base_data.get("infrastructure") or "unknown"
summary_types_val = base_data.get("types") if isinstance(base_data.get("types"), list) else []
summary_types = ", ".join(str(x) for x in summary_types_val) if summary_types_val else "none"
analysis_present = "yes" if base_data.get("analysis_output") else "no"

def colorize(text: str, color: str) -> str:
    return f"{color}{text}{nc}"

def status_label(error: str) -> str:
    if error is None:
        return colorize("ok", green)
    if error == "missing":
        return colorize("missing", yellow)
    return colorize(error, red)

if match_status == "identical":
    consistency_msg = colorize("OK - cache and project artifacts match", green)
elif match_status == "mismatch":
    consistency_msg = colorize("MISMATCH - cache and project artifacts differ", red)
else:
    reasons = []
    if proj_error:
        reasons.append(f"project {proj_error}")
    if cache_error:
        reasons.append(f"cache {cache_error}")
    if not reasons:
        reasons.append("insufficient data")
    consistency_msg = colorize("Unable to verify - " + "; ".join(reasons), yellow)

lines = [
    f"{blue}Init Status{nc}",
    f"  Project slug: {summary_slug}",
    f"  Project path: {summary_path}",
    f"  Project file: {project_path}",
    f"    Status: {status_label(proj_error)}",
    f"  Cache file: {cache_path}",
    f"    Status: {status_label(cache_error)}",
    f"  Cache consistency: {consistency_msg}",
    "",
    "  Detected attributes:",
    f"    Timestamp: {summary_timestamp}",
    f"    Language: {summary_language}",
    f"    Framework: {summary_framework}",
    f"    Infrastructure: {summary_infra}",
    f"    Types: {summary_types}",
]

if analysis_present == "yes":
    lines.append("    analyze_project output stored in detection.json")

exit_code = 0
if proj_error is not None or cache_error is not None or match_status == "mismatch":
    exit_code = 1

summary_text = "\n".join(lines)

warnings = []
if proj_error:
    warnings.append(colorize(f"Project detection.json {proj_error}", red))
if cache_error:
    warnings.append(colorize(f"Cache detection.json {cache_error}", red))
if match_status == "mismatch":
    warnings.append(colorize("Cache and project detection artifacts differ", red))
elif match_status == "unverified" and not (proj_error or cache_error):
    warnings.append(colorize("Unable to verify cache consistency", yellow))

if mode == "summary":
    print(summary_text)
    sys.exit(exit_code)

for message in warnings:
    print(message, file=sys.stderr)

output_text = None
if proj_data is not None:
    output_text = proj_text
elif cache_data is not None:
    output_text = cache_text

if output_text is None:
    print(colorize(f"No detection artifacts found for slug '{slug}'.", red), file=sys.stderr)
    sys.exit(1)

sys.stdout.write(output_text)
if not output_text.endswith("\n"):
    sys.stdout.write("\n")

sys.exit(exit_code)
PY
    return $?
}

init_reset() {
    ensure_init_dirs
    echo -e "${YELLOW}TODO:${NC} init_reset placeholder."
}

init_resume() {
    ensure_init_dirs
    echo -e "${YELLOW}TODO:${NC} init_resume placeholder."
}

scenario_parse_metadata() {
    local scenario_file="$1"
    python3 - "$scenario_file" <<'PY'
import sys
import shlex
from pathlib import Path

import yaml

path = Path(sys.argv[1])
if not path.exists():
    print(f"ERROR:missing scenario '{path}'", flush=True)
    sys.exit(1)

try:
    data = yaml.safe_load(path.read_text(encoding='utf-8')) or {}
except yaml.YAMLError as exc:
    print(f"ERROR:yaml {exc}", flush=True)
    sys.exit(1)

def q(value: str) -> str:
    return shlex.quote(value) if value is not None else "''"

name = data.get('name') or path.stem
description = data.get('description') or ''
priority = data.get('priority') or 'normal'
scenario_type = data.get('type') or 'operational'

phases = data.get('phases') or []
if not isinstance(phases, list):
    print('ERROR:invalid phases', flush=True)
    sys.exit(1)

print(f"SCENARIO_NAME={q(name)}")
print(f"SCENARIO_DESCRIPTION={q(description)}")
print(f"SCENARIO_PRIORITY={q(priority)}")
print(f"SCENARIO_TYPE={q(scenario_type)}")
print(f"PHASE_COUNT={len(phases)}")

def flatten(items):
    result = []
    for item in items:
        if isinstance(item, str):
            if item:
                result.append(item)
        elif isinstance(item, dict):
            for key, value in item.items():
                if isinstance(value, str) and value:
                    result.append(f"{key}:{value}")
                else:
                    result.append(str(key))
        elif item is not None:
            result.append(str(item))
    return result

for idx, phase in enumerate(phases):
    if not isinstance(phase, dict):
        print(f"ERROR:phase_{idx}_not_object", flush=True)
        sys.exit(1)
    pname = phase.get('name') or f'phase_{idx + 1}'
    pdesc = phase.get('description') or ''
    condition = phase.get('condition') or 'manual'
    parallel = bool(phase.get('parallel', False))
    agents = flatten(phase.get('agents') or [])
    profiles = flatten(phase.get('profiles') or [])
    success = flatten(phase.get('success_criteria') or [])

    print(f"PHASE_NAME_{idx}={q(pname)}")
    print(f"PHASE_DESC_{idx}={q(pdesc)}")
    print(f"PHASE_CONDITION_{idx}={q(condition)}")
    print(f"PHASE_PARALLEL_{idx}={'true' if parallel else 'false'}")
    print(f"PHASE_AGENTS_{idx}={q(','.join(agents))}")
    print(f"PHASE_PROFILES_{idx}={q(','.join(profiles))}")
    print(f"PHASE_SUCCESS_{idx}={q(','.join(success))}")
PY
}

scenario_list() {
    ensure_scenarios_dir
    python3 - "$SCENARIOS_DIR" <<'PY'
import sys
from pathlib import Path

import yaml

root = Path(sys.argv[1])

scenarios = []
for path in sorted(root.glob('*.yaml')):
    try:
        data = yaml.safe_load(path.read_text(encoding='utf-8')) or {}
    except yaml.YAMLError:
        scenarios.append((path.stem, 'invalid YAML', 'error'))
        continue
    scenarios.append((
        data.get('name') or path.stem,
        data.get('description') or 'No description provided',
        data.get('priority') or 'normal'
    ))

if not scenarios:
    print('No scenarios defined. Add YAML files under ~/.claude/scenarios/.')
else:
    print('Available scenarios:\n')
    for name, desc, priority in scenarios:
        print(f"- {name} [priority: {priority}]\n  {desc}")
PY
}

scenario_validate_targets() {
    local targets=()
    if [[ $# -eq 0 ]] || [[ "$1" == "--all" ]]; then
        while IFS= read -r path; do
            [[ -z "$path" ]] && continue
            targets+=("$path")
        done < <(find "$SCENARIOS_DIR" -maxdepth 1 -type f -name "*.yaml" | sort)
    else
        local scenario_name
        for scenario_name in "$@"; do
            local normalized="$scenario_name"
            [[ "$normalized" != *.yaml ]] && normalized="${normalized}.yaml"
            local candidate="$SCENARIOS_DIR/$normalized"
            if [[ -f "$candidate" ]]; then
                targets+=("$candidate")
            else
                echo -e "${RED}Scenario file not found: $scenario_name${NC}"
            fi
        done
    fi
    printf '%s\n' "${targets[@]}"
}

scenario_validate() {
    ensure_scenarios_dir
    local targets=()
    while IFS= read -r path; do
        [[ -z "$path" ]] && continue
        targets+=("$path")
    done < <(scenario_validate_targets "$@")
    if [[ ${#targets[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No scenario files found for validation${NC}"
        return 0
    fi

    python3 - "$SCENARIO_SCHEMA" "${targets[@]}" <<'PY'
import sys
from pathlib import Path

import yaml

schema_path = Path(sys.argv[1])
schema = {}
if schema_path.exists():
    schema = yaml.safe_load(schema_path.read_text(encoding='utf-8')) or {}

allowed_types = set(schema.get('fields', {}).get('type', {}).get('enum', []))
allowed_priorities = set(schema.get('fields', {}).get('priority', {}).get('enum', []))
allowed_conditions = set(schema.get('fields', {}).get('condition', {}).get('enum', []))

def ensure_list(value, key, messages):
    if value is None:
        return []
    if isinstance(value, list):
        return value
    messages.append(f"'{key}' must be a list")
    return []

overall_status = 0

for raw in sys.argv[2:]:
    path = Path(raw)
    messages = []
    warnings = []
    try:
        data = yaml.safe_load(path.read_text(encoding='utf-8')) or {}
    except yaml.YAMLError as exc:
        print(f"[ERROR] {path.name}: YAML parse error - {exc}")
        overall_status = 1
        continue

    for key in schema.get('required', []):
        if not data.get(key):
            messages.append(f"missing required field '{key}'")

    scenario_type = data.get('type', 'operational')
    if allowed_types and scenario_type not in allowed_types:
        warnings.append(f"unknown type '{scenario_type}' (allowed: {sorted(allowed_types)})")

    priority = data.get('priority', 'normal')
    if allowed_priorities and priority not in allowed_priorities:
        warnings.append(f"unknown priority '{priority}' (allowed: {sorted(allowed_priorities)})")

    phases = data.get('phases')
    if not isinstance(phases, list) or not phases:
        messages.append("'phases' must be a non-empty list")
        phases = []

    for idx, phase in enumerate(phases):
        if not isinstance(phase, dict):
            messages.append(f"phase {idx}: must be an object")
            continue
        if not phase.get('name'):
            messages.append(f"phase {idx}: missing 'name'")
        if 'agents' not in phase and 'profiles' not in phase:
            warnings.append(f"phase {idx}: no agents or profiles defined")
        condition = phase.get('condition', 'manual')
        if allowed_conditions and condition not in allowed_conditions:
            warnings.append(f"phase {idx}: unknown condition '{condition}' (allowed: {sorted(allowed_conditions)})")
        ensure_list(phase.get('agents'), f"phases[{idx}].agents", messages)
        ensure_list(phase.get('profiles'), f"phases[{idx}].profiles", messages)

    if messages:
        print(f"[ERROR] {path.name}: {'; '.join(messages)}")
        overall_status = 1
        continue

    for warning in warnings:
        print(f"[WARN] {path.name}: {warning}")

    print(f"[OK] {path.name}: valid scenario definition")

sys.exit(overall_status)
PY
}

scenario_status() {
    ensure_scenarios_dir
    python3 - "$SCENARIO_STATE_DIR" "$SCENARIO_LOCK_DIR" <<'PY'
import json
import sys
from pathlib import Path

state_dir = Path(sys.argv[1])
lock_dir = Path(sys.argv[2])

locks = []
if lock_dir.exists():
    for lock in sorted(lock_dir.glob('*.lock')):
        locks.append((lock.stem, lock.read_text(encoding='utf-8').strip()))

if locks:
    print('Active locks:')
    for scenario, exec_id in locks:
        print(f"- {scenario}: execution {exec_id}")
    print('')

if not state_dir.exists():
    print('No scenario executions logged yet.')
    sys.exit(0)

entries = []
for state_file in sorted(state_dir.glob('*.json'), reverse=True):
    try:
        data = json.loads(state_file.read_text(encoding='utf-8'))
    except json.JSONDecodeError:
        continue
    entries.append((
        data.get('scenario'),
        data.get('status'),
        data.get('started'),
        data.get('completed')
    ))

if not entries:
    print('No scenario executions logged yet.')
else:
    print('Recent scenario executions:\n')
    for scenario, status, started, completed in entries[:10]:
        print(f"- {scenario} ({status})")
        print(f"  started: {started}")
        if completed:
            print(f"  completed: {completed}")
PY
}

scenario_stop() {
    ensure_scenarios_dir
    local scenario_name="$1"
    if [[ -z "$scenario_name" ]]; then
        echo -e "${RED}Provide a scenario name to stop${NC}"
        return 1
    fi
    local lock_file="$SCENARIO_LOCK_DIR/${scenario_name}.lock"
    if [[ ! -f "$lock_file" ]]; then
        echo -e "${YELLOW}No active lock for scenario '$scenario_name'${NC}"
        return 0
    fi
    rm -f "$lock_file"
    echo -e "${GREEN}Cleared lock for scenario '$scenario_name'${NC}"
}

scenario_run() {
    local scenario_name="$1"
    shift

    if [[ -z "$scenario_name" ]]; then
        echo -e "${RED}Specify a scenario name${NC}"
        scenario_list
        return 1
    fi

    local run_mode="interactive"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto|--automatic|automatic) run_mode="automatic" ;;
            --interactive|interactive) run_mode="interactive" ;;
            --plan|--preview|--validate|preview|plan|validate) run_mode="plan" ;;
            *) echo -e "${YELLOW}Ignoring unknown option '$1'${NC}" ;;
        esac
        shift
    done

    ensure_scenarios_dir
    local scenario_file="$SCENARIOS_DIR/${scenario_name}.yaml"
    if [[ ! -f "$scenario_file" ]]; then
        echo -e "${RED}Scenario file not found: $scenario_name${NC}"
        scenario_list
        return 1
    fi

    local parsed
    if ! parsed=$(scenario_parse_metadata "$scenario_file"); then
        echo "$parsed" | sed 's/^ERROR:/Error:/'
        return 1
    fi

    eval "$parsed"

    if [[ "$run_mode" == "plan" ]]; then
        echo -e "${BLUE}Scenario preview: ${SCENARIO_NAME}${NC}"
        echo "Description: $SCENARIO_DESCRIPTION"
        echo "Priority: $SCENARIO_PRIORITY"
        echo "Type: $SCENARIO_TYPE"
        echo "Phases: $PHASE_COUNT"
        local idx
        for ((idx=0; idx<PHASE_COUNT; idx++)); do
            local name_var="PHASE_NAME_${idx}"
            local agents_var="PHASE_AGENTS_${idx}"
            local profiles_var="PHASE_PROFILES_${idx}"
            local condition_var="PHASE_CONDITION_${idx}"
            local parallel_var="PHASE_PARALLEL_${idx}"
            local desc_var="PHASE_DESC_${idx}"
            echo ""
            echo "- Phase $((idx + 1)): ${!name_var}"
            [[ -n "${!desc_var}" ]] && echo "  ${!desc_var}"
            echo "  condition: ${!condition_var}"
            echo "  parallel: ${!parallel_var}"
            [[ -n "${!profiles_var}" ]] && echo "  profiles: ${!profiles_var}"
            [[ -n "${!agents_var}" ]] && echo "  agents: ${!agents_var}"
        done
        return 0
    fi

    local exec_id
    exec_id=$(date +%s)
    local lock_file="$SCENARIO_LOCK_DIR/${SCENARIO_NAME}.lock"
    if [[ -f "$lock_file" ]]; then
        echo -e "${RED}Scenario '$SCENARIO_NAME' already running (lock present). Use 'claude-ctx orchestrate stop $SCENARIO_NAME' if the previous run is stuck.${NC}"
        return 1
    fi
    echo "$exec_id" > "$lock_file"
    trap 'rm -f "$lock_file"' RETURN

    local state_file="$SCENARIO_STATE_DIR/${SCENARIO_NAME}-${exec_id}.json"
    scenario_init_state "$state_file" "$SCENARIO_NAME" "$SCENARIO_DESCRIPTION" "$scenario_file"

    echo -e "${BLUE}=== Executing scenario: ${SCENARIO_NAME} ===${NC}"
    echo "Description: $SCENARIO_DESCRIPTION"
    echo "Priority: $SCENARIO_PRIORITY"
    echo "Type: $SCENARIO_TYPE"
    echo "Run mode: $run_mode"
    echo "Execution id: $exec_id"
    echo ""

    local idx
    for ((idx=0; idx<PHASE_COUNT; idx++)); do
        local name_var="PHASE_NAME_${idx}"
        local agents_var="PHASE_AGENTS_${idx}"
        local profiles_var="PHASE_PROFILES_${idx}"
        local condition_var="PHASE_CONDITION_${idx}"
        local parallel_var="PHASE_PARALLEL_${idx}"
        local success_var="PHASE_SUCCESS_${idx}"
        local desc_var="PHASE_DESC_${idx}"

        local phase_name="${!name_var}"
        local phase_agents="${!agents_var}"
        local phase_profiles="${!profiles_var}"
        local phase_condition="${!condition_var}"
        local phase_parallel="${!parallel_var}"
        local phase_desc="${!desc_var}"

        echo -e "${YELLOW}Phase $((idx + 1)): $phase_name${NC}"
        [[ -n "$phase_desc" ]] && echo "  $phase_desc"
        echo "  condition: $phase_condition"
        echo "  parallel: $phase_parallel"
        [[ -n "$phase_profiles" ]] && echo "  profiles: $phase_profiles"
        [[ -n "$phase_agents" ]] && echo "  agents: $phase_agents"
        [[ -n "${!success_var}" ]] && echo "  success checks: ${!success_var}"

        if [[ "$phase_condition" != "manual" && "$run_mode" == "interactive" ]]; then
            read -r -p "Execute this phase now? [y/N] " confirmation
            if [[ ! "$confirmation" =~ ^[Yy]$ ]]; then
                echo "  Skipping phase on user request"
                scenario_update_phase_state "$state_file" "$phase_name" "$idx" "skipped" "user skipped"
                continue
            fi
        fi

        scenario_update_phase_state "$state_file" "$phase_name" "$idx" "running" ""

        if [[ -n "$phase_profiles" ]]; then
            IFS=',' read -r -a profile_items <<< "$phase_profiles"
            local profile
            for profile in "${profile_items[@]}"; do
                [[ -z "$profile" ]] && continue
                echo "  -> Loading profile: $profile"
                if ! profile_load "$profile" >/dev/null 2>&1; then
                    echo -e "    ${RED}Failed to load profile '$profile'${NC}"
                fi
            done
        fi

        if [[ -n "$phase_agents" ]]; then
            IFS=',' read -r -a agent_items <<< "$phase_agents"
            local agent
            for agent in "${agent_items[@]}"; do
                [[ -z "$agent" ]] && continue
                echo "  -> Activating agent: $agent"
                if ! agent_activate "$agent" >/dev/null 2>&1; then
                    echo -e "    ${YELLOW}Warning: could not activate '$agent'${NC}"
                fi
            done
        fi

        generate_dependency_map
        scenario_update_phase_state "$state_file" "$phase_name" "$idx" "completed" ""
        echo ""
    done

    scenario_finalize_state "$state_file" "completed"
    echo -e "${GREEN}Scenario '${SCENARIO_NAME}' completed${NC}"
}

# Helper function to check if path contains disabled directory
# NOTE: This prevents the CLI tool from showing/activating disabled items,
# BUT Claude Code itself still loads directories recursively!
#
# IMPORTANT: To prevent Claude Code from loading disabled items:
# 1. Move them completely outside the active directory tree, or
# 2. Use a different file extension (e.g., .md.disabled)
#
# This function helps manage items via CLI but doesn't affect Claude Code's loading.
is_disabled() {
    local path="$1"
    [[ "$path" =~ /disabled/ ]] || [[ "$path" =~ /inactive/ ]]
}

# Function to show usage
show_help() {
    echo "Claude Context Manager - Optimize token usage"
    echo ""
    echo "Usage: $0 [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  mode activate <mode>     - Activate a behavioral mode"
    echo "  mode deactivate <mode>   - Deactivate a behavioral mode"
    echo "  mode list               - List available modes"
    echo "  mode status             - Show active modes"
    echo ""
    echo "  agent activate <agent>   - Activate an agent"
    echo "  agent deactivate <agent> [--force] - Deactivate an agent"
    echo "  agent list              - List available agents"
    echo "  agent status            - Show active agents"
    echo "  agent validate [target] - Validate agent metadata (default: all active agents)"
    echo "  agent deps <agent>      - Show dependency information for an agent"
    echo "  agent graph [--export path] - Print dependency graph (and optionally export dependencies.map)"
    echo ""
    echo "  rules activate <rule>    - Activate a rule module"
    echo "  rules deactivate <rule>  - Deactivate a rule module"
    echo "  rules list              - List available rule modules"
    echo ""
    echo "  profile <name>          - Load a predefined profile"
    echo "  profile save <name>     - Save current config as profile"
    echo "  profile list            - List saved profiles"
    echo ""
    echo "  workflow run <name>     - Run a predefined workflow"
    echo "  workflow list           - List available workflows"
    echo "  workflow status         - Show current workflow progress"
    echo "  workflow resume         - Resume interrupted workflow"
    echo ""
    echo "  cmd <ns:command>        - Execute a namespaced command"
    echo "  cmd list [namespace]    - List available commands"
    echo "  cmd search <query>      - Search for commands"
    echo ""
    echo "  task resume             - Resume last task"
    echo "  task status             - Show task progress"
    echo "  task complete <id>      - Mark task complete"
    echo ""
    echo "  cleanup                 - Move disabled/ dirs outside active tree (fixes Claude Code loading)"
    echo "  init [--interactive]    - Run initialization wizard for the current project"
    echo "  init detect             - Detect project context and refresh init cache"
    echo "  init minimal            - Apply minimal defaults via init system"
    echo "  init profile <name>     - Placeholder: capture profile selection for init"
    echo "  init status             - Show stored init state for this project"
    echo "  init reset              - Clear init state for this project"
    echo "  init --resume           - Resume the last init session"
    echo "  analyze                 - Analyze project and recommend configuration"
    echo "  optimize [--apply]      - Auto-optimize for current project"
    echo "  status                  - Show complete status"
    echo "  reset                  - Reset to default minimal config"
    echo ""
    echo "Modes: brainstorming, introspection, orchestration, token-efficiency, task-management"
    echo "Profiles: minimal, frontend, web-dev, backend, devops, documentation, data-ai, quality, meta, developer-experience, product, full"
    echo "Workflows: feature-development, bug-fix, security-audit, performance-optimize"
}

# Function to backup CLAUDE.md
backup_config() {
    cp "$CLAUDE_MD" "$CLAUDE_MD.backup.$(date +%s)"
}

# Function to update CLAUDE.md with current active items
update_claude_md() {
    backup_config

    cat > "$CLAUDE_MD" << 'EOF'
# Claude Framework Entry Point

# Core Framework
@FLAGS.md
@PRINCIPLES.md
@RULES.md

# Workflow Rules (load for all development tasks)
@rules/workflow-rules.md

# Conditional Rules (load as needed)
EOF

    # Add active rule modules
    for rule in quality-rules efficiency-rules; do
        if [[ -f "$RULES_DIR/$rule.md" ]] && ! grep -q "^# @rules/$rule.md" "$CLAUDE_MD" 2>/dev/null; then
            if [[ -f "$CLAUDE_DIR/.active-rules" ]] && grep -q "$rule" "$CLAUDE_DIR/.active-rules"; then
                echo "@rules/$rule.md" >> "$CLAUDE_MD"
            else
                echo "# @rules/$rule.md    # Uncomment to activate" >> "$CLAUDE_MD"
            fi
        fi
    done

    cat >> "$CLAUDE_MD" << 'EOF'

# Active Behavioral Modes
EOF

    # Add active modes
    if [[ -f "$CLAUDE_DIR/.active-modes" ]]; then
        while IFS= read -r mode; do
            echo "@modes/$mode.md" >> "$CLAUDE_MD"
        done < "$CLAUDE_DIR/.active-modes"
    fi

    cat >> "$CLAUDE_MD" << 'EOF'

# Inactive Modes (move to active/ as needed)
EOF

    # Add inactive modes as comments
    for mode_file in "$MODES_DIR/inactive"/*.md; do
        if [[ -f "$mode_file" ]]; then
            mode_name=$(basename "$mode_file" .md)
            echo "# @modes/inactive/$mode_name.md" >> "$CLAUDE_MD"
        fi
    done

    cat >> "$CLAUDE_MD" << 'EOF'

# MCP Documentation
@mcp/docs/Context7.md
@mcp/docs/Sequential.md
@mcp/docs/Serena.md
EOF
}

# Mode management functions
mode_activate() {
    local mode="$1"
    local mode_file="$MODES_DIR/inactive/${mode}.md"
    local active_file="$MODES_DIR/${mode}.md"

    if [[ ! -f "$mode_file" ]]; then
        echo -e "${RED}Mode '$mode' not found in inactive modes${NC}"
        return 1
    fi

    mv "$mode_file" "$active_file"
    echo "$mode" >> "$CLAUDE_DIR/.active-modes"
    echo -e "${GREEN}Activated mode: $mode${NC}"
    update_claude_md
}

mode_deactivate() {
    local mode="$1"
    local mode_file="$MODES_DIR/${mode}.md"
    local inactive_file="$MODES_DIR/inactive/${mode}.md"

    if [[ ! -f "$mode_file" ]]; then
        echo -e "${RED}Mode '$mode' is not currently active${NC}"
        return 1
    fi

    mv "$mode_file" "$inactive_file"
    sed -i.bak "/^$mode$/d" "$CLAUDE_DIR/.active-modes" 2>/dev/null
    echo -e "${YELLOW}Deactivated mode: $mode${NC}"
    update_claude_md
}

mode_list() {
    echo -e "${BLUE}Available modes:${NC}"
    if [[ -d "$MODES_DIR/inactive" ]]; then
        for mode_file in "$MODES_DIR/inactive"/*.md; do
            if [[ -f "$mode_file" ]]; then
                mode_name=$(basename "$mode_file" .md)
                echo "  $mode_name (inactive)"
            fi
        done
    fi
    if [[ -d "$MODES_DIR/disabled" ]]; then
        for mode_file in "$MODES_DIR/disabled"/*.md; do
            if [[ -f "$mode_file" ]]; then
                mode_name=$(basename "$mode_file" .md)
                echo "  $mode_name (disabled)"
            fi
        done
    fi

    for mode_file in "$MODES_DIR"/*.md; do
        if [[ -f "$mode_file" ]] && ! is_disabled "$mode_file"; then
            mode_name=$(basename "$mode_file" .md)
            echo -e "  ${GREEN}$mode_name (active)${NC}"
        fi
    done
}

mode_status() {
    echo -e "${BLUE}Active modes:${NC}"
    if [[ -f "$CLAUDE_DIR/.active-modes" ]]; then
        while IFS= read -r mode; do
            echo -e "  ${GREEN}$mode${NC}"
        done < "$CLAUDE_DIR/.active-modes"
    else
        echo "  None"
    fi
}

# Agent management functions
agent_activate() {
    local agent="$1"
    if [[ -z "$agent" ]]; then
        echo -e "${RED}Please specify an agent to activate${NC}"
        return 1
    fi

    local filename
    if ! filename=$(normalize_agent_filename "$agent"); then
        echo -e "${RED}Unable to normalize agent name '$agent'${NC}"
        return 1
    fi
    local agent_name
    agent_name=$(agent_basename "$filename")

    local active_file="$AGENTS_DIR/$filename"
    if [[ -f "$active_file" ]]; then
        echo -e "${YELLOW}Agent '$agent_name' is already active${NC}"
        return 0
    fi

    local agent_file
    if ! agent_file=$(find_disabled_agent_file "$filename"); then
        echo -e "${RED}Agent '$agent_name' not found in disabled agents${NC}"
        echo "Checked: agents-disabled/ and agents/disabled/"
        return 1
    fi

    if [[ ":$ACTIVATION_STACK:" == *":$agent_name:"* ]]; then
        echo -e "${RED}Dependency cycle detected while activating '$agent_name'${NC}"
        return 1
    fi

    local requires_list=()
    local recommends_list=()
    local section=""
    while IFS= read -r line; do
        case "$line" in
            --REQUIRES--) section="requires"; continue ;;
            --RECOMMENDS--) section="recommends"; continue ;;
        esac
        [[ -z "$line" ]] && continue
        if [[ "$section" == "requires" ]]; then
            requires_list+=("$line")
        elif [[ "$section" == "recommends" ]]; then
            recommends_list+=("$line")
        fi
    done < <(read_agent_dependencies "$agent_file")

    local prev_stack="$ACTIVATION_STACK"
    ACTIVATION_STACK="${ACTIVATION_STACK}:${agent_name}"

    for dep in "${requires_list[@]}"; do
        [[ -z "$dep" ]] && continue
        local dep_name="${dep%.md}"
        if [[ "$dep_name" == "$agent_name" ]]; then
            continue
        fi
        if ! agent_activate "$dep_name"; then
            ACTIVATION_STACK="$prev_stack"
            return 1
        fi
    done

    mkdir -p "$AGENTS_DIR"
    if mv "$agent_file" "$active_file"; then
        echo -e "${GREEN}Activated agent: $agent_name${NC}"
        if [[ ${#recommends_list[@]} -gt 0 ]]; then
            echo -e "${YELLOW}Consider activating:${NC} ${recommends_list[*]}"
        fi
        generate_dependency_map
    else
        echo -e "${RED}Failed to activate agent '$agent_name'${NC}"
        ACTIVATION_STACK="$prev_stack"
        return 1
    fi

    ACTIVATION_STACK="$prev_stack"
    return 0
}

agent_deactivate() {
    local agent="$1"
    local flag="$2"
    if [[ -z "$agent" ]]; then
        echo -e "${RED}Please specify an agent to deactivate${NC}"
        return 1
    fi

    local force=false
    if [[ "$flag" == "--force" ]]; then
        force=true
    fi

    local filename
    if ! filename=$(normalize_agent_filename "$agent"); then
        echo -e "${RED}Unable to normalize agent name '$agent'${NC}"
        return 1
    fi
    local agent_name
    agent_name=$(agent_basename "$filename")
    local agent_file="$AGENTS_DIR/${filename}"
    local disabled_file=""

    if [[ ! -f "$agent_file" ]]; then
        echo -e "${RED}Agent '$agent_name' is not currently active${NC}"
        return 1
    fi

    local dependents=()
    for other_agent_file in "$AGENTS_DIR"/*.md; do
        [[ -f "$other_agent_file" ]] || continue
        if is_disabled "$other_agent_file"; then
            continue
        fi
        [[ "$other_agent_file" == "$agent_file" ]] && continue

        local section=""
        local requires_list=()
        while IFS= read -r line; do
            case "$line" in
                --REQUIRES--) section="requires"; continue ;;
                --RECOMMENDS--) section="recommends"; continue ;;
            esac
            [[ -z "$line" ]] && continue
            if [[ "$section" == "requires" ]]; then
                requires_list+=("$line")
            fi
        done < <(read_agent_dependencies "$other_agent_file")

        local other_name
        other_name=$(agent_basename "$other_agent_file")
        for dep in "${requires_list[@]}"; do
            [[ -z "$dep" ]] && continue
            local dep_name
            dep_name=$(agent_basename "$(normalize_agent_filename "$dep")")
            if [[ "$dep_name" == "$agent_name" ]]; then
                dependents+=("$other_name")
                break
            fi
        done
    done

    if [[ ${#dependents[@]} -gt 0 && $force == false ]]; then
        echo -e "${RED}Cannot deactivate '$agent_name' while required by:${NC} ${dependents[*]}"
        echo "Use 'claude-ctx agent deps $agent_name' to inspect relationships or '--force' to override."
        return 1
    fi

    # Prefer agents-disabled/ (cleaner structure for Claude Code)
    if [[ -d "$CLAUDE_DIR/agents-disabled" ]]; then
        disabled_file="$CLAUDE_DIR/agents-disabled/${filename}"
    else
        # Fall back to agents/disabled/ for backward compatibility
        mkdir -p "$AGENTS_DIR/disabled"
        disabled_file="$AGENTS_DIR/disabled/${filename}"
    fi

    mv "$agent_file" "$disabled_file"
    echo -e "${YELLOW}Deactivated agent: $agent_name${NC}"
    if [[ ${#dependents[@]} -gt 0 ]]; then
        echo -e "${YELLOW}Warning:${NC} left dependents without required agent: ${dependents[*]}"
    fi
    generate_dependency_map
}

agent_list() {
    echo -e "${BLUE}Available agents:${NC}"

    # Show disabled agents from both locations
    if [[ -d "$AGENTS_DIR/disabled" ]]; then
        for agent_file in "$AGENTS_DIR/disabled"/*; do
            if [[ -f "$agent_file" ]]; then
                [[ "$agent_file" != *.md ]] && continue
                agent_name=$(agent_basename "$agent_file")
                echo "  $agent_name (disabled - in agents/disabled/)"
            fi
        done
    fi
    if [[ -d "$CLAUDE_DIR/agents-disabled" ]]; then
        for agent_file in "$CLAUDE_DIR/agents-disabled"/*; do
            if [[ -f "$agent_file" ]]; then
                [[ "$agent_file" != *.md ]] && continue
                agent_name=$(agent_basename "$agent_file")
                echo "  $agent_name (disabled - in agents-disabled/)"
            fi
        done
    fi

    # Show active agents
    for agent_file in "$AGENTS_DIR"/*; do
        if [[ -f "$agent_file" ]] && ! is_disabled "$agent_file"; then
            [[ "$agent_file" != *.md ]] && continue
            agent_name=$(agent_basename "$agent_file")
            echo -e "  ${GREEN}$agent_name (active)${NC}"
        fi
    done
}

agent_status() {
    echo -e "${BLUE}Active agents:${NC}"
    local count=0
    for agent_file in "$AGENTS_DIR"/*; do
        if [[ -f "$agent_file" ]] && ! is_disabled "$agent_file"; then
            [[ "$agent_file" != *.md ]] && continue
            agent_name=$(agent_basename "$agent_file")
            echo -e "  ${GREEN}$agent_name${NC}"
            ((count++))
        fi
    done
    echo -e "${BLUE}Total active agents: $count${NC}"
}

agent_validate() {
    local args=()

    if [[ $# -eq 0 ]] || [[ "$1" == "--all" ]]; then
        for agent_file in "$AGENTS_DIR"/*.md; do
            [[ -f "$agent_file" ]] || continue
            [[ $(basename "$agent_file") == "TRIGGERS.md" ]] && continue
            args+=("$agent_file")
        done
        # Optionally include disabled agents for validation parity
        if [[ -d "$CLAUDE_DIR/agents-disabled" ]]; then
            for agent_file in "$CLAUDE_DIR/agents-disabled"/*.md; do
                [[ -f "$agent_file" ]] || continue
                [[ $(basename "$agent_file") == "TRIGGERS.md" ]] && continue
                args+=("$agent_file")
            done
        fi
        # Skip the leading --all if provided
        [[ "$1" == "--all" ]] && shift
    fi

    while [[ $# -gt 0 ]]; do
        local target="$1"
        if [[ -f "$target" ]]; then
            args+=("$target")
        elif [[ -f "$AGENTS_DIR/$target" ]]; then
            [[ "$target" == "TRIGGERS.md" ]] && { shift; continue; }
            args+=("$AGENTS_DIR/$target")
        elif [[ -f "$CLAUDE_DIR/agents-disabled/$target" ]]; then
            args+=("$CLAUDE_DIR/agents-disabled/$target")
        else
            echo -e "${RED}Agent file not found: $target${NC}"
            return 1
        fi
        shift
    done

    if [[ ${#args[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No agent files found for validation${NC}"
        return 0
    fi

    python3 - "${args[@]}" <<'PY'
import sys
import pathlib
import yaml

schema_path = pathlib.Path.home() / ".claude" / "schema" / "agent-schema-v2.yaml"
try:
    schema = yaml.safe_load(schema_path.read_text())
except FileNotFoundError:
    print(f"[ERROR] Schema file missing: {schema_path}")
    sys.exit(1)

required_keys = schema.get("required", [])
fields = schema.get("fields", {})

allowed_categories = set(fields.get("category", {}).get("enum", []))
tier_fields = fields.get("tier", {}).get("properties", {})
allowed_tiers = set(tier_fields.get("id", {}).get("enum", []))
allowed_strategies = set(tier_fields.get("activation_strategy", {}).get("enum", []))

def dotted_get(data, dotted_key):
    current = data
    for part in dotted_key.split('.'):
        if not isinstance(current, dict) or part not in current:
            return None
        current = current[part]
    return current

errors = []
warnings = []
validated = 0

for agent_path in sys.argv[1:]:
    path = pathlib.Path(agent_path)
    if not path.exists():
        errors.append(f"[ERROR] Missing file: {agent_path}")
        continue

    text = path.read_text()
    if not text.lstrip().startswith('---'):
        errors.append(f"[ERROR] {path}: missing YAML front matter")
        continue

    segments = text.split('---', 2)
    if len(segments) < 3:
        errors.append(f"[ERROR] {path}: malformed front matter delimiter")
        continue

    header = segments[1]
    try:
        metadata = yaml.safe_load(header) or {}
    except yaml.YAMLError as exc:
        errors.append(f"[ERROR] {path}: YAML parse failure - {exc}")
        continue

    version = metadata.get("version")
    if str(version) != "2.0":
        warnings.append(f"[WARN] {path}: version {version or 'missing'} - skipping schema v2 validation")
        continue

    local_errors = []

    for key in required_keys:
        value = dotted_get(metadata, key)
        if value in (None, ""):
            local_errors.append(f"missing required field '{key}'")

    category = metadata.get("category")
    if category and allowed_categories and category not in allowed_categories:
        local_errors.append(f"invalid category '{category}' (allowed: {sorted(allowed_categories)})")

    tier = metadata.get("tier")
    if isinstance(tier, dict):
        tier_id = tier.get("id")
        if allowed_tiers and tier_id not in allowed_tiers:
            local_errors.append(f"invalid tier.id '{tier_id}' (allowed: {sorted(allowed_tiers)})")
        strategy = tier.get("activation_strategy")
        if strategy and allowed_strategies and strategy not in allowed_strategies:
            local_errors.append(f"invalid tier.activation_strategy '{strategy}' (allowed: {sorted(allowed_strategies)})")
    else:
        local_errors.append("'tier' must be an object")

    tools = metadata.get("tools", {})
    catalog = tools.get("catalog") if isinstance(tools, dict) else None
    if not isinstance(catalog, list) or not catalog:
        local_errors.append("'tools.catalog' must be a non-empty list")

    dependencies = metadata.get("dependencies")
    if dependencies and not isinstance(dependencies, dict):
        local_errors.append("'dependencies' must be an object when provided")

    if local_errors:
        joined = '; '.join(local_errors)
        errors.append(f"[ERROR] {path}: {joined}")
        continue

    validated += 1

for warning in warnings:
    print(warning)

if errors:
    for err in errors:
        print(err)
    if validated:
        print(f"Validated {validated} agent(s) before failures.")
    sys.exit(1)

print(f"Validated {validated} agent(s) against schema v2.0.")
PY

    local status=$?
    if [[ $status -eq 0 ]]; then
        echo -e "${GREEN}Agent metadata conforms to schema v2.0${NC}"
    else
        echo -e "${RED}Agent metadata validation failed${NC}"
    fi
    return $status
}

agent_deps() {
    local agent="$1"
    if [[ -z "$agent" ]]; then
        echo -e "${RED}Usage:${NC} $0 agent deps <agent_name>"
        return 1
    fi

    local filename
    if ! filename=$(normalize_agent_filename "$agent"); then
        echo -e "${RED}Unable to normalize agent name '$agent'${NC}"
        return 1
    fi

    local agent_path
    if ! agent_path=$(find_agent_file_any_state "$filename"); then
        echo -e "${RED}Agent '$(agent_basename "$filename")' not found in active or disabled directories${NC}"
        return 1
    fi

    local agent_name
    agent_name=$(agent_basename "$filename")

    local requires_list=()
    local recommends_list=()
    local section=""
    while IFS= read -r line; do
        case "$line" in
            --REQUIRES--) section="requires"; continue ;;
            --RECOMMENDS--) section="recommends"; continue ;;
        esac
        [[ -z "$line" ]] && continue
        if [[ "$section" == "requires" ]]; then
            requires_list+=("$line")
        elif [[ "$section" == "recommends" ]]; then
            recommends_list+=("$line")
        fi
    done < <(read_agent_dependencies "$agent_path")

    local status_label="disabled"
    if [[ "$agent_path" == "$AGENTS_DIR/$filename" ]]; then
        status_label="active"
    fi

    echo -e "${BLUE}Agent:${NC} $agent_name ($status_label)"
    local requires_output=()
    for dep in "${requires_list[@]}"; do
        [[ -z "$dep" ]] && continue
        local dep_filename
        dep_filename=$(normalize_agent_filename "$dep") || continue
        local dep_base
        dep_base=$(agent_basename "$dep_filename")
        local dep_status="missing"
        if [[ -f "$AGENTS_DIR/$dep_filename" ]]; then
            dep_status="active"
        elif [[ -f "$CLAUDE_DIR/agents-disabled/$dep_filename" ]] || [[ -f "$AGENTS_DIR/disabled/$dep_filename" ]]; then
            dep_status="disabled"
        fi
        requires_output+=("$dep_base ($dep_status)")
    done

    local recommends_output=()
    for dep in "${recommends_list[@]}"; do
        [[ -z "$dep" ]] && continue
        local dep_filename
        dep_filename=$(normalize_agent_filename "$dep") || continue
        local dep_base
        dep_base=$(agent_basename "$dep_filename")
        local dep_status="missing"
        if [[ -f "$AGENTS_DIR/$dep_filename" ]]; then
            dep_status="active"
        elif [[ -f "$CLAUDE_DIR/agents-disabled/$dep_filename" ]] || [[ -f "$AGENTS_DIR/disabled/$dep_filename" ]]; then
            dep_status="disabled"
        fi
        recommends_output+=("$dep_base ($dep_status)")
    done

    if [[ ${#requires_output[@]} -gt 0 ]]; then
        local requires_str
        requires_str=$(printf '%s, ' "${requires_output[@]}")
        requires_str=${requires_str%, }
        echo -e "${BLUE}Requires:${NC} $requires_str"
    else
        echo -e "${BLUE}Requires:${NC} (none)"
    fi

    if [[ ${#recommends_output[@]} -gt 0 ]]; then
        local recommends_str
        recommends_str=$(printf '%s, ' "${recommends_output[@]}")
        recommends_str=${recommends_str%, }
        echo -e "${BLUE}Recommends:${NC} $recommends_str"
    else
        echo -e "${BLUE}Recommends:${NC} (none)"
    fi
}

agent_graph() {
    local export_path=""
    if [[ "$1" == "--export" ]]; then
        if [[ -z "$2" ]]; then
            echo -e "${RED}Usage:${NC} $0 agent graph [--export <path>]"
            return 1
        fi
        export_path="$2"
        shift 2
    fi

    local python_output
    python_output=$(python3 - "$AGENTS_DIR" "$CLAUDE_DIR/agents-disabled" <<'PY'
import sys
from pathlib import Path

import yaml

active_dir = Path(sys.argv[1])
disabled_dir = Path(sys.argv[2])

def parse_agent(path, status):
    try:
        text = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        return None
    text = text.lstrip()
    if not text.startswith('---'):
        return None
    parts = text.split('---', 2)
    if len(parts) < 3:
        return None
    try:
        metadata = yaml.safe_load(parts[1]) or {}
    except yaml.YAMLError:
        return None

    if str(metadata.get('version')) != '2.0':
        return None

    name = metadata.get('name') or path.stem
    category = metadata.get('category') or 'unknown'
    tier = metadata.get('tier', {}).get('id') or 'unknown'
    dependencies = metadata.get('dependencies') or {}
    requires = [item for item in (dependencies.get('requires') or []) if item]
    recommends = [item for item in (dependencies.get('recommends') or []) if item]

    return {
        'name': name,
        'category': category,
        'tier': tier,
        'status': status,
        'requires': requires,
        'recommends': recommends,
    }

agents = []

if active_dir.exists():
    for path in sorted(active_dir.glob('*.md')):
        data = parse_agent(path, 'active')
        if data:
            agents.append(data)

if disabled_dir.exists():
    for path in sorted(disabled_dir.glob('*.md')):
        data = parse_agent(path, 'disabled')
        if data:
            agents.append(data)

agents.sort(key=lambda item: (item['category'], item['name']))

if not agents:
    print("No v2 agents found.")
    sys.exit(0)

max_name = max(len(a['name']) for a in agents)
max_cat = max(len(a['category']) for a in agents)
max_tier = max(len(a['tier']) for a in agents)
header = f"{'Name'.ljust(max_name)}  {'Category'.ljust(max_cat)}  {'Tier'.ljust(max_tier)}  Status   Requires   Recommends"
print(header)
print('-' * len(header))

for agent in agents:
    requires = ', '.join(agent['requires']) if agent['requires'] else '-'
    recommends = ', '.join(agent['recommends']) if agent['recommends'] else '-'
    line = f"{agent['name'].ljust(max_name)}  {agent['category'].ljust(max_cat)}  {agent['tier'].ljust(max_tier)}  {agent['status'].ljust(7)}  {requires or '-'}  {recommends or '-'}"
    print(line)

print("__EXPORT__")
print("# Auto-generated by claude-ctx agent graph")
print("# Format: agent:requires:recommends")
for agent in agents:
    requires = ','.join(agent['requires'])
    recommends = ','.join(agent['recommends'])
    print(f"{agent['name']}:{requires}:{recommends}")
PY
)
    local py_status=$?
    if [[ $py_status -ne 0 ]]; then
        return $py_status
    fi

    local table_output
    table_output=$(printf "%s" "$python_output" | sed '/^__EXPORT__$/,$d')
    printf "%s\n" "$table_output"

    if [[ -n "$export_path" ]]; then
        local map_output
        map_output=$(printf "%s" "$python_output" | sed -n '/^__EXPORT__$/,$p' | tail -n +2)
        if [[ -n "$map_output" ]]; then
            local dest="${export_path/#\~/$HOME}"
            local dest_dir
            dest_dir=$(dirname -- "$dest")
            if [[ "$dest_dir" != "." ]]; then
                mkdir -p "$dest_dir"
            fi
            printf "%s\n" "$map_output" > "$dest"
            echo ""
            if [[ -e "$dest" ]]; then
                local resolved
                resolved=$(cd "$dest_dir" 2>/dev/null && pwd -P 2>/dev/null)
                if [[ -n "$resolved" ]]; then
                    echo "Exported dependency map to $resolved/$(basename -- "$dest")"
                else
                    echo "Exported dependency map to $dest"
                fi
            else
                echo "Exported dependency map to $dest"
            fi
        fi
    fi
}

# Rules management functions
rules_activate() {
    local rule="$1"
    echo "$rule" >> "$CLAUDE_DIR/.active-rules"
    sed -i.bak "s|^# @rules/$rule.md.*|@rules/$rule.md|" "$CLAUDE_MD"
    echo -e "${GREEN}Activated rule module: $rule${NC}"
}

rules_deactivate() {
    local rule="$1"
    sed -i.bak "/^$rule$/d" "$CLAUDE_DIR/.active-rules" 2>/dev/null
    sed -i.bak "s|^@rules/$rule.md|# @rules/$rule.md    # Uncomment to activate|" "$CLAUDE_MD"
    echo -e "${YELLOW}Deactivated rule module: $rule${NC}"
}

rules_list() {
    echo -e "${BLUE}Available rule modules:${NC}"
    for rule_file in "$RULES_DIR"/*.md; do
        if [[ -f "$rule_file" ]] && ! is_disabled "$rule_file"; then
            rule_name=$(basename "$rule_file" .md)
            if [[ -f "$CLAUDE_DIR/.active-rules" ]] && grep -q "$rule_name" "$CLAUDE_DIR/.active-rules"; then
                echo -e "  ${GREEN}$rule_name (active)${NC}"
            else
                echo "  $rule_name (inactive)"
            fi
        fi
    done
}

# Profile management
profile_load() {
    local profile="$1"

    case "$profile" in
        "minimal")
            # Reset to minimal
            profile_reset
            ;;
        "frontend")
            profile_reset
            agent_activate "react-specialist"
            agent_activate "websocket-engineer"
            agent_activate "electron-pro"
            agent_activate "javascript-pro"
            agent_activate "typescript-pro"
            mode_activate "Task_Management"
            rules_activate "quality-rules"
            ;;
        "web-dev")
            profile_reset
            agent_activate "typescript-pro"
            agent_activate "ui-ux-designer"
            agent_activate "javascript-pro"
            mode_activate "Task_Management"
            rules_activate "quality-rules"
            ;;
        "backend")
            profile_reset
            agent_activate "python-pro"
            agent_activate "database-optimizer"
            agent_activate "security-auditor"
            agent_activate "api-documenter"
            mode_activate "Task_Management"
            rules_activate "quality-rules"
            ;;
        "devops")
            profile_reset
            agent_activate "cloud-architect"
            agent_activate "kubernetes-architect"
            agent_activate "terraform-specialist"
            agent_activate "deployment-engineer"
            mode_activate "Orchestration"
            rules_activate "efficiency-rules"
            ;;
        "documentation")
            profile_reset
            agent_activate "docs-architect"
            agent_activate "api-documenter"
            agent_activate "system-architect"
            agent_activate "code-reviewer"
            mode_activate "Task_Management"
            rules_activate "quality-rules"
            ;;
        "data-ai")
            profile_reset
            agent_activate "ai-engineer"
            agent_activate "ml-engineer"
            agent_activate "mlops-engineer"
            agent_activate "data-engineer"
            agent_activate "data-scientist"
            agent_activate "prompt-engineer"
            mode_activate "Task_Management"
            rules_activate "quality-rules"
            ;;
        "quality")
            profile_reset
            agent_activate "code-reviewer"
            agent_activate "quality-engineer"
            agent_activate "test-automator"
            agent_activate "performance-engineer"
            agent_activate "security-auditor"
            agent_activate "penetration-tester"
            agent_activate "compliance-auditor"
            mode_activate "Task_Management"
            rules_activate "quality-rules"
            ;;
        "meta")
            profile_reset
            agent_activate "context-manager"
            agent_activate "root-cause-analyst"
            agent_activate "incident-responder"
            agent_activate "devops-troubleshooter"
            agent_activate "agent-organizer"
            agent_activate "task-distributor"
            agent_activate "multi-agent-coordinator"
            agent_activate "workflow-orchestrator"
            agent_activate "performance-monitor"
            agent_activate "knowledge-synthesizer"
            agent_activate "error-coordinator"
            mode_activate "Orchestration"
            rules_activate "efficiency-rules"
            ;;
        "developer-experience")
            profile_reset
            agent_activate "dx-optimizer"
            agent_activate "legacy-modernizer"
            agent_activate "refactoring-expert"
            agent_activate "technical-writer"
            agent_activate "docs-architect"
            agent_activate "build-engineer"
            agent_activate "tooling-engineer"
            agent_activate "cli-developer"
            agent_activate "git-workflow-manager"
            mode_activate "Task_Management"
            rules_activate "quality-rules"
            ;;
        "product")
            profile_reset
            agent_activate "product-manager"
            agent_activate "legal-advisor"
            agent_activate "compliance-auditor"
            agent_activate "content-marketer"
            agent_activate "business-analyst"
            mode_activate "Task_Management"
            rules_activate "quality-rules"
            ;;
        "full")
            # Activate everything (not recommended)
            for agent_file in "$AGENTS_DIR/disabled"/*; do
                if [[ -f "$agent_file" ]]; then
                    agent_name=$(basename "$agent_file")
                    agent_activate "$agent_name"
                fi
            done
            for mode_file in "$MODES_DIR/inactive"/*.md; do
                if [[ -f "$mode_file" ]]; then
                    mode_name=$(basename "$mode_file" .md)
                    mode_activate "$mode_name"
                fi
            done
            rules_activate "quality-rules"
            rules_activate "efficiency-rules"
            ;;
        *)
            echo -e "${RED}Unknown profile: $profile${NC}"
            echo "Available profiles: minimal, web-dev, backend, devops, documentation, full"
            return 1
            ;;
    esac

    generate_dependency_map

    local missing_recs
    missing_recs=$(collect_missing_recommends)
    if [[ -n "$missing_recs" ]]; then
        echo -e "${YELLOW}Recommended but inactive agents:${NC}"
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            echo "  $line"
        done <<< "$missing_recs"
    fi

    echo -e "${GREEN}Loaded profile: $profile${NC}"
    update_claude_md
}

profile_save() {
    local profile_name="$1"
    local profile_dir="$CLAUDE_DIR/profiles"

    mkdir -p "$profile_dir"

    # Save current state - collect only active agents (excluding disabled/)
    local active_agents=""
    for agent_file in "$AGENTS_DIR"/*; do
        if [[ -f "$agent_file" ]] && ! is_disabled "$agent_file"; then
            active_agents="$active_agents $(basename "$agent_file")"
        fi
    done

    cat > "$profile_dir/$profile_name.profile" << EOF
# Profile: $profile_name
# Generated: $(date)

# Active agents
AGENTS="$active_agents"

# Active modes
MODES="$(cat "$CLAUDE_DIR/.active-modes" 2>/dev/null | tr '\n' ' ')"

# Active rules
RULES="$(cat "$CLAUDE_DIR/.active-rules" 2>/dev/null | tr '\n' ' ')"
EOF

    echo -e "${GREEN}Saved profile: $profile_name${NC}"
}

profile_list() {
    echo -e "${BLUE}Available profiles:${NC}"
    echo "  minimal (built-in)"
    echo "  frontend (built-in)"
    echo "  web-dev (built-in)"
    echo "  backend (built-in)"
    echo "  devops (built-in)"
    echo "  documentation (built-in)"
    echo "  data-ai (built-in)"
    echo "  quality (built-in)"
    echo "  meta (built-in)"
    echo "  developer-experience (built-in)"
    echo "  product (built-in)"
    echo "  full (built-in)"

    if [[ -d "$CLAUDE_DIR/profiles" ]]; then
        for profile_file in "$CLAUDE_DIR/profiles"/*.profile; do
            if [[ -f "$profile_file" ]]; then
                profile_name=$(basename "$profile_file" .profile)
                echo -e "  ${GREEN}$profile_name (saved)${NC}"
            fi
        done
    fi
}

profile_reset() {
    # Move all agents to disabled except essential ones
    local essential_agents=("code-reviewer" "debugger" "typescript-pro" "python-pro" "security-auditor")

    for agent_file in "$AGENTS_DIR"/*; do
        if [[ -f "$agent_file" ]] && ! is_disabled "$agent_file"; then
            [[ "$agent_file" != *.md ]] && continue
            local agent_name
            agent_name=$(agent_basename "$agent_file")
            if [[ ! " ${essential_agents[@]} " =~ " ${agent_name} " ]]; then
                agent_deactivate "$agent_name" --force
            fi
        fi
    done

    for essential in "${essential_agents[@]}"; do
        agent_activate "$essential" >/dev/null 2>&1 || true
    done

    # Move all modes to inactive except Task_Management
    for mode_file in "$MODES_DIR"/*.md; do
        if [[ -f "$mode_file" ]] && ! is_disabled "$mode_file"; then
            mode_name=$(basename "$mode_file" .md)
            if [[ "$mode_name" != "Task_Management" ]]; then
                mode_deactivate "$mode_name"
            fi
        fi
    done

    # Clear active rules
    rm -f "$CLAUDE_DIR/.active-rules"

    echo -e "${GREEN}Reset to minimal configuration${NC}"
    update_claude_md
}

# Workflow management functions
workflow_run() {
    local workflow="$1"
    local workflow_file="$WORKFLOWS_DIR/${workflow}.yaml"

    if [[ ! -f "$workflow_file" ]]; then
        echo -e "${RED}Workflow '$workflow' not found${NC}"
        echo "Available workflows:"
        workflow_list
        return 1
    fi

    # Create task directory for this workflow
    mkdir -p "$TASKS_DIR/current"

    # Save workflow state
    echo "$workflow" > "$TASKS_DIR/current/active_workflow"
    echo "pending" > "$TASKS_DIR/current/workflow_status"
    date +%s > "$TASKS_DIR/current/workflow_started"

    echo -e "${GREEN}Started workflow: $workflow${NC}"
    echo ""
    echo -e "${BLUE}Workflow steps will be executed by Claude Code${NC}"
    echo "To check progress: $0 workflow status"
    echo "To resume if interrupted: $0 workflow resume"
    echo ""
    echo -e "${YELLOW}Next: Open Claude Code and the workflow will guide you${NC}"

    # Show workflow summary
    echo ""
    echo -e "${BLUE}=== Workflow: $workflow ===${NC}"
    grep "^description:" "$workflow_file" | sed 's/description: //'
    echo ""
    echo -e "${BLUE}Steps:${NC}"
    grep "^  - name:" "$workflow_file" | sed 's/  - name: /   /'
}

workflow_list() {
    echo -e "${BLUE}Available workflows:${NC}"
    for workflow_file in "$WORKFLOWS_DIR"/*.yaml; do
        if [[ -f "$workflow_file" ]]; then
            workflow_name=$(basename "$workflow_file" .yaml)
            if [[ "$workflow_name" != "README" ]]; then
                desc=$(grep "^description:" "$workflow_file" | sed 's/description: //')
                echo -e "  ${GREEN}$workflow_name${NC}"
                echo "    $desc"
            fi
        fi
    done
}

workflow_status() {
    if [[ ! -f "$TASKS_DIR/current/active_workflow" ]]; then
        echo -e "${YELLOW}No active workflow${NC}"
        return 0
    fi

    local workflow=$(cat "$TASKS_DIR/current/active_workflow")
    local status=$(cat "$TASKS_DIR/current/workflow_status" 2>/dev/null || echo "unknown")
    local started=$(cat "$TASKS_DIR/current/workflow_started" 2>/dev/null || echo "0")
    local elapsed=$(($(date +%s) - started))
    local hours=$((elapsed / 3600))
    local minutes=$(((elapsed % 3600) / 60))

    echo -e "${BLUE}=== Active Workflow ===${NC}"
    echo -e "Workflow: ${GREEN}$workflow${NC}"
    echo -e "Status: $status"
    echo -e "Elapsed time: ${hours}h ${minutes}m"

    if [[ -f "$TASKS_DIR/current/current_step" ]]; then
        local step=$(cat "$TASKS_DIR/current/current_step")
        echo -e "Current step: ${YELLOW}$step${NC}"
    fi
}

workflow_resume() {
    if [[ ! -f "$TASKS_DIR/current/active_workflow" ]]; then
        echo -e "${YELLOW}No workflow to resume${NC}"
        return 1
    fi

    local workflow=$(cat "$TASKS_DIR/current/active_workflow")
    echo -e "${GREEN}Resuming workflow: $workflow${NC}"

    if [[ -f "$TASKS_DIR/current/current_step" ]]; then
        local step=$(cat "$TASKS_DIR/current/current_step")
        echo -e "Resuming from step: ${YELLOW}$step${NC}"
    fi

    echo ""
    echo -e "${BLUE}Continue in Claude Code - the workflow context has been restored${NC}"
}

# Task management functions
task_resume() {
    if [[ ! -d "$TASKS_DIR/current" ]]; then
        echo -e "${YELLOW}No active task to resume${NC}"
        return 1
    fi

    echo -e "${GREEN}Resuming last task session${NC}"

    if [[ -f "$TASKS_DIR/current/active.json" ]]; then
        echo -e "${BLUE}Task context:${NC}"
        cat "$TASKS_DIR/current/active.json" | jq -r '.description // "No description"' 2>/dev/null || cat "$TASKS_DIR/current/active.json"
    fi

    if [[ -f "$TASKS_DIR/current/checkpoint" ]]; then
        echo ""
        echo -e "${BLUE}Last checkpoint:${NC}"
        cat "$TASKS_DIR/current/checkpoint"
    fi
}

task_status() {
    if [[ ! -d "$TASKS_DIR/current" ]]; then
        echo -e "${YELLOW}No active task${NC}"
        return 0
    fi

    echo -e "${BLUE}=== Task Status ===${NC}"

    local total=0
    local completed=0

    if [[ -d "$TASKS_DIR/current/queue" ]]; then
        total=$(find "$TASKS_DIR/current/queue" -type f | wc -l | tr -d ' ')
    fi

    if [[ -d "$TASKS_DIR/current/completed" ]]; then
        completed=$(find "$TASKS_DIR/current/completed" -type f | wc -l | tr -d ' ')
    fi

    echo "Total tasks: $total"
    echo "Completed: $completed"
    echo "Remaining: $((total - completed))"

    if [[ -f "$TASKS_DIR/current/active.json" ]]; then
        echo ""
        echo -e "${BLUE}Current task:${NC}"
        cat "$TASKS_DIR/current/active.json" | jq -r '.description // "No description"' 2>/dev/null || cat "$TASKS_DIR/current/active.json"
    fi
}

task_complete() {
    local task_id="$1"

    if [[ -z "$task_id" ]]; then
        echo -e "${RED}Please provide a task ID${NC}"
        return 1
    fi

    mkdir -p "$TASKS_DIR/current/completed"

    if [[ -f "$TASKS_DIR/current/queue/$task_id" ]]; then
        mv "$TASKS_DIR/current/queue/$task_id" "$TASKS_DIR/current/completed/$task_id.$(date +%s)"
        echo -e "${GREEN}Task $task_id marked as complete${NC}"
    else
        echo -e "${RED}Task $task_id not found${NC}"
    fi
}

# Command management functions
cmd_run() {
    local cmd_path="$1"

    # Parse namespace:command format
    if [[ "$cmd_path" == *":"* ]]; then
        local namespace="${cmd_path%%:*}"
        local command="${cmd_path#*:}"
        local cmd_file="$COMMANDS_DIR/$namespace/$command.md"
    else
        echo -e "${RED}Command must be in format namespace:command${NC}"
        echo "Example: dev:code-review, test:generate-tests"
        return 1
    fi

    if [[ ! -f "$cmd_file" ]]; then
        echo -e "${RED}Command '$cmd_path' not found${NC}"
        echo ""
        cmd_list "$namespace"
        return 1
    fi

    echo -e "${GREEN}Executing command: $cmd_path${NC}"
    echo ""

    # Extract command details
    local description=$(grep "^description:" "$cmd_file" | sed 's/description: //' | tr -d '"')
    local agents=$(grep "^agents:" "$cmd_file" | sed 's/agents: //')

    echo -e "${BLUE}Description:${NC} $description"
    if [[ -n "$agents" ]]; then
        echo -e "${BLUE}Agents:${NC} $agents"
    fi
    echo ""

    # Show command content
    echo -e "${BLUE}=== Command Instructions ===${NC}"
    sed -n '/^---$/,/^---$/!p' "$cmd_file" | tail -n +2

    echo ""
    echo -e "${YELLOW}Command loaded. Continue in Claude Code to execute.${NC}"
}

cmd_list() {
    local namespace="$1"

    if [[ -z "$namespace" ]]; then
        echo -e "${BLUE}Available command namespaces:${NC}"
        for ns_dir in "$COMMANDS_DIR"/*; do
            if [[ -d "$ns_dir" ]] && [[ $(basename "$ns_dir") != "nf" ]] && ! is_disabled "$ns_dir"; then
                local ns_name=$(basename "$ns_dir")
                # Count only non-disabled command files
                local cmd_count=0
                for cmd_file in "$ns_dir"/*.md; do
                    if [[ -f "$cmd_file" ]] && ! is_disabled "$cmd_file"; then
                        ((cmd_count++))
                    fi
                done
                echo -e "  ${GREEN}$ns_name${NC} ($cmd_count commands)"
            fi
        done
        echo ""
        echo "Use '$0 cmd list <namespace>' to see commands in a namespace"
    else
        local ns_dir="$COMMANDS_DIR/$namespace"
        if [[ ! -d "$ns_dir" ]]; then
            echo -e "${RED}Namespace '$namespace' not found${NC}"
            return 1
        fi

        echo -e "${BLUE}Commands in namespace '$namespace':${NC}"
        for cmd_file in "$ns_dir"/*.md; do
            if [[ -f "$cmd_file" ]] && [[ $(basename "$cmd_file") != "README.md" ]] && ! is_disabled "$cmd_file"; then
                local cmd_name=$(basename "$cmd_file" .md)
                local description=$(grep "^description:" "$cmd_file" | sed 's/description: //' | tr -d '"')
                echo -e "  ${GREEN}$namespace:$cmd_name${NC}"
                if [[ -n "$description" ]]; then
                    echo "    $description"
                fi
            fi
        done
    fi
}

cmd_search() {
    local query="$1"

    if [[ -z "$query" ]]; then
        echo -e "${RED}Please provide a search query${NC}"
        return 1
    fi

    echo -e "${BLUE}Searching commands for: $query${NC}"
    echo ""

    local found=0
    for cmd_file in "$COMMANDS_DIR"/*/*.md; do
        if [[ -f "$cmd_file" ]] && [[ $(basename "$cmd_file") != "README.md" ]] && ! is_disabled "$cmd_file"; then
            if grep -qi "$query" "$cmd_file"; then
                local namespace=$(basename $(dirname "$cmd_file"))
                local cmd_name=$(basename "$cmd_file" .md)
                local description=$(grep "^description:" "$cmd_file" | sed 's/description: //' | tr -d '"')

                echo -e "  ${GREEN}$namespace:$cmd_name${NC}"
                if [[ -n "$description" ]]; then
                    echo "    $description"
                fi
                ((found++))
            fi
        fi
    done

    if [[ $found -eq 0 ]]; then
        echo -e "${YELLOW}No commands found matching '$query'${NC}"
    else
        echo ""
        echo -e "${BLUE}Found $found matching command(s)${NC}"
    fi
}

# Project type detection and analysis
detect_project_type() {
    local project_types=()
    local primary_language=""
    local framework=""
    local infrastructure=""
    local has_docker=0
    local has_kubernetes=0
    local has_terraform=0
    local has_github_actions=0

    # Language detection
    if [[ -f "package.json" ]]; then
        primary_language="javascript"
        if [[ -f "tsconfig.json" ]]; then
            primary_language="typescript"
        fi

        # Framework detection
        if grep -q '"react"' package.json; then
            framework="react"
        elif grep -q '"vue"' package.json; then
            framework="vue"
        elif grep -q '"angular"' package.json; then
            framework="angular"
        elif grep -q '"next"' package.json; then
            framework="nextjs"
        elif grep -q '"express"\|"fastify"\|"koa"' package.json; then
            framework="nodejs-backend"
        fi
    elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]]; then
        primary_language="python"

        if [[ -f "manage.py" ]] || grep -q "django" requirements.txt 2>/dev/null; then
            framework="django"
        elif grep -q "flask" requirements.txt 2>/dev/null; then
            framework="flask"
        elif grep -q "fastapi" requirements.txt 2>/dev/null; then
            framework="fastapi"
        fi
    elif [[ -f "Cargo.toml" ]]; then
        primary_language="rust"
    elif [[ -f "go.mod" ]]; then
        primary_language="go"
    elif [[ -f "pom.xml" ]] || [[ -f "build.gradle" ]]; then
        primary_language="java"
    fi

    # Infrastructure detection
    if [[ -f "Dockerfile" ]]; then
        has_docker=1
        [[ -z "$infrastructure" ]] && infrastructure="docker"
    fi
    if [[ -f "docker-compose.yml" ]] || [[ -f "docker-compose.yaml" ]]; then
        has_docker=1
        [[ -z "$infrastructure" ]] && infrastructure="docker-compose"
    fi
    if [[ -d "k8s" ]] || [[ -d "kubernetes" ]] || [[ -f "deployment.yaml" ]]; then
        has_kubernetes=1
        [[ -z "$infrastructure" ]] && infrastructure="kubernetes"
    fi
    if [[ -f "terraform.tfvars" ]] || [[ -d "terraform" ]] || compgen -G "*.tf" > /dev/null; then
        has_terraform=1
        [[ -z "$infrastructure" ]] && infrastructure="terraform"
    fi
    if [[ -d ".github/workflows" ]]; then
        has_github_actions=1
        [[ -z "$infrastructure" ]] && infrastructure="github-actions"
    fi

    # Project type classification
    if [[ "$framework" == "react" ]] || [[ "$framework" == "vue" ]] || [[ "$framework" == "angular" ]] || [[ "$framework" == "nextjs" ]]; then
        project_types+=("frontend")
    fi

    if [[ "$framework" == "nodejs-backend" ]] || [[ "$framework" == "django" ]] || [[ "$framework" == "flask" ]] || [[ "$framework" == "fastapi" ]]; then
        project_types+=("backend")
    fi

    if [[ $has_docker -eq 1 || $has_kubernetes -eq 1 || $has_terraform -eq 1 || $has_github_actions -eq 1 ]]; then
        project_types+=("devops")
    fi

    # Determine if full-stack
    if [[ " ${project_types[@]} " =~ " frontend " ]] && [[ " ${project_types[@]} " =~ " backend " ]]; then
        project_types+=("fullstack")
    fi

    # Output detection results
    echo "$primary_language|$framework|$infrastructure|${project_types[*]}"
}

# Smart mode selection based on project analysis
analyze_project() {
    echo -e "${BLUE}Analyzing project structure...${NC}"
    echo ""

    local detection=$(detect_project_type)
    IFS='|' read -r language framework infrastructure types <<< "$detection"

    # Display analysis
    echo -e "${GREEN}Project Analysis:${NC}"
    [[ -n "$language" ]] && echo "  Language: $language"
    [[ -n "$framework" ]] && echo "  Framework: $framework"
    [[ -n "$infrastructure" ]] && echo "  Infrastructure: $infrastructure"
    [[ -n "$types" ]] && echo "  Type: $types"
    echo ""

    # Recommend configuration
    echo -e "${BLUE}Recommended Configuration:${NC}"

    if [[ "$types" =~ "fullstack" ]]; then
        echo "  Profile: full-stack"
        echo "  Agents: typescript-pro, python-pro, deployment-engineer"
        echo "  Modes: Task_Management"
    elif [[ "$types" =~ "frontend" ]]; then
        echo "  Profile: web-dev"
        echo "  Agents: typescript-pro, ui-ux-designer"
        echo "  Modes: Task_Management"
    elif [[ "$types" =~ "backend" ]]; then
        echo "  Profile: backend"
        if [[ "$language" == "python" ]]; then
            echo "  Agents: python-pro, database-optimizer, security-auditor"
        else
            echo "  Agents: typescript-pro, database-optimizer, security-auditor"
        fi
        echo "  Modes: Task_Management"
    elif [[ "$types" =~ "devops" ]]; then
        echo "  Profile: devops"
        echo "  Agents: deployment-engineer, cloud-architect, kubernetes-architect"
        echo "  Modes: Orchestration"
    else
        echo "  Profile: minimal"
        echo "  Using basic configuration"
    fi

    echo ""
    echo "Apply this configuration with: $0 optimize --apply"
}

# Auto-optimization based on project detection
auto_optimize() {
    local apply_mode="$1"

    if [[ "$apply_mode" != "--apply" ]]; then
        analyze_project
        return 0
    fi

    echo -e "${BLUE}Auto-optimizing for current project...${NC}"

    local detection=$(detect_project_type)
    IFS='|' read -r language framework infrastructure types <<< "$detection"

    # Apply optimal configuration
    if [[ "$types" =~ "fullstack" ]]; then
        echo "Configuring for full-stack development"
        profile_reset
        [[ "$language" == "typescript" ]] && agent_activate "typescript-pro"
        [[ "$language" == "python" ]] && agent_activate "python-pro"
        agent_activate "deployment-engineer"
        mode_activate "Task_Management"
        rules_activate "quality-rules"

    elif [[ "$types" =~ "frontend" ]]; then
        echo "Configuring for frontend development"
        profile_load "web-dev"

    elif [[ "$types" =~ "backend" ]]; then
        echo "Configuring for backend development"
        profile_load "backend"

    elif [[ "$types" =~ "devops" ]]; then
        echo "Configuring for DevOps"
        profile_load "devops"

    else
        echo "Unknown project type, using minimal config"
        profile_load "minimal"
    fi

    echo -e "${GREEN}Configuration applied successfully!${NC}"
}

# Cleanup disabled directories to prevent Claude Code from loading them
cleanup_disabled() {
    echo -e "${BLUE}Cleaning up disabled/inactive directories...${NC}"
    echo ""
    echo "This will move disabled items outside the active directory tree"
    echo "to prevent Claude Code from loading them recursively."
    echo ""

    local total_moved=0

    # Handle agents/disabled
    if [[ -d "$AGENTS_DIR/disabled" ]]; then
        local count=$(find "$AGENTS_DIR/disabled" -type f | wc -l | tr -d ' ')
        if [[ $count -gt 0 ]]; then
            echo -e "${YELLOW}Moving $count agents from agents/disabled/ to agents-disabled/${NC}"
            mkdir -p "$CLAUDE_DIR/agents-disabled"
            mv "$AGENTS_DIR/disabled"/* "$CLAUDE_DIR/agents-disabled/" 2>/dev/null || true
            rmdir "$AGENTS_DIR/disabled" 2>/dev/null || true
            ((total_moved += count))
        fi
    fi

    # Handle modes/inactive
    if [[ -d "$MODES_DIR/inactive" ]]; then
        local count=$(find "$MODES_DIR/inactive" -type f | wc -l | tr -d ' ')
        if [[ $count -gt 0 ]]; then
            echo -e "${YELLOW}Moving $count modes from modes/inactive/ to modes-inactive/${NC}"
            mkdir -p "$CLAUDE_DIR/modes-inactive"
            mv "$MODES_DIR/inactive"/* "$CLAUDE_DIR/modes-inactive/" 2>/dev/null || true
            rmdir "$MODES_DIR/inactive" 2>/dev/null || true
            ((total_moved += count))
        fi
    fi

    # Handle modes/disabled (if exists)
    if [[ -d "$MODES_DIR/disabled" ]]; then
        local count=$(find "$MODES_DIR/disabled" -type f | wc -l | tr -d ' ')
        if [[ $count -gt 0 ]]; then
            echo -e "${YELLOW}Moving $count modes from modes/disabled/ to modes-disabled/${NC}"
            mkdir -p "$CLAUDE_DIR/modes-disabled"
            mv "$MODES_DIR/disabled"/* "$CLAUDE_DIR/modes-disabled/" 2>/dev/null || true
            rmdir "$MODES_DIR/disabled" 2>/dev/null || true
            ((total_moved += count))
        fi
    fi

    # Handle rules/disabled (if exists)
    if [[ -d "$RULES_DIR/disabled" ]]; then
        local count=$(find "$RULES_DIR/disabled" -type f | wc -l | tr -d ' ')
        if [[ $count -gt 0 ]]; then
            echo -e "${YELLOW}Moving $count rules from rules/disabled/ to rules-disabled/${NC}"
            mkdir -p "$CLAUDE_DIR/rules-disabled"
            mv "$RULES_DIR/disabled"/* "$CLAUDE_DIR/rules-disabled/" 2>/dev/null || true
            rmdir "$RULES_DIR/disabled" 2>/dev/null || true
            ((total_moved += count))
        fi
    fi

    # Handle commands namespaces with disabled subdirectories
    if [[ -d "$COMMANDS_DIR" ]]; then
        for ns_dir in "$COMMANDS_DIR"/*; do
            if [[ -d "$ns_dir/disabled" ]]; then
                local ns_name=$(basename "$ns_dir")
                local count=$(find "$ns_dir/disabled" -type f | wc -l | tr -d ' ')
                if [[ $count -gt 0 ]]; then
                    echo -e "${YELLOW}Moving $count commands from commands/$ns_name/disabled/ to commands-disabled/$ns_name/${NC}"
                    mkdir -p "$CLAUDE_DIR/commands-disabled/$ns_name"
                    mv "$ns_dir/disabled"/* "$CLAUDE_DIR/commands-disabled/$ns_name/" 2>/dev/null || true
                    rmdir "$ns_dir/disabled" 2>/dev/null || true
                    ((total_moved += count))
                fi
            fi
        done
    fi

    echo ""
    if [[ $total_moved -gt 0 ]]; then
        echo -e "${GREEN}Successfully moved $total_moved items outside active directory tree${NC}"
        echo ""
        echo "To re-enable items, use:"
        echo "  claude-ctx agent activate <filename>   (from agents-disabled/)"
        echo "  claude-ctx mode activate <name>        (from modes-inactive/)"
    else
        echo -e "${GREEN}No disabled directories found - all clean!${NC}"
    fi
}

# Status overview
show_status() {
    echo -e "${BLUE}=== Claude Context Status ===${NC}"
    echo ""
    agent_status
    echo ""
    mode_status
    echo ""
    echo -e "${BLUE}Active rule modules:${NC}"
    if [[ -f "$CLAUDE_DIR/.active-rules" ]]; then
        while IFS= read -r rule; do
            echo -e "  ${GREEN}$rule${NC}"
        done < "$CLAUDE_DIR/.active-rules"
    else
        echo "  None"
    fi
}

# Main command dispatcher
case "$1" in
    "mode")
        case "$2" in
            "activate") mode_activate "$3" ;;
            "deactivate") mode_deactivate "$3" ;;
            "list") mode_list ;;
            "status") mode_status ;;
            *) echo "Usage: $0 mode {activate|deactivate|list|status} [mode_name]" ;;
        esac
        ;;
    "agent")
        case "$2" in
            "activate") agent_activate "$3" ;;
            "deactivate") agent_deactivate "$3" "$4" ;;
            "list") agent_list ;;
            "status") agent_status ;;
            "deps") agent_deps "$3" ;;
            "graph") agent_graph "${@:3}" ;;
            "validate") agent_validate "${@:3}" ;;
            *) echo "Usage: $0 agent {activate|deactivate|list|status|validate|deps|graph} [args]" ;;
        esac
        ;;
    "rules")
        case "$2" in
            "activate") rules_activate "$3" ;;
            "deactivate") rules_deactivate "$3" ;;
            "list") rules_list ;;
            *) echo "Usage: $0 rules {activate|deactivate|list} [rule_name]" ;;
        esac
        ;;
    "profile")
        case "$2" in
            "save") profile_save "$3" ;;
            "list") profile_list ;;
            *) profile_load "$2" ;;
        esac
        ;;
    "workflow")
        case "$2" in
            "run") workflow_run "$3" ;;
            "list") workflow_list ;;
            "status") workflow_status ;;
            "resume") workflow_resume ;;
            *) echo "Usage: $0 workflow {run|list|status|resume} [workflow_name]" ;;
        esac
        ;;
    "init")
        case "$2" in
            ""|"--interactive"|"-i") init_wizard "${@:3}" ;;
            "detect") init_detect "${@:3}" ;;
            "minimal") init_minimal "${@:3}" ;;
            "profile") init_profile "$3" ;;
            "status") init_status "${@:3}" ;;
            "reset") init_reset "${@:3}" ;;
            "--resume"|"resume") init_resume "${@:3}" ;;
            *) echo "Usage: $0 init [--interactive|detect|minimal|profile <name>|status|reset|--resume]" ;;
        esac
        ;;
    "orchestrate"|"orch")
        case "$2" in
            "list") scenario_list ;;
            "run") scenario_run "$3" "${@:4}" ;;
            "validate") scenario_validate "${@:3}" ;;
            "status") scenario_status ;;
            "stop") scenario_stop "$3" ;;
            "preview") scenario_run "$3" plan ;;
            *)
                echo "Usage: $0 orchestrate {list|run|validate|status|stop|preview} [scenario]"
                ;;
        esac
        ;;
    "cmd"|"command")
        case "$2" in
            "list") cmd_list "$3" ;;
            "search") cmd_search "$3" ;;
            *) cmd_run "$2" ;;
        esac
        ;;
    "task")
        case "$2" in
            "resume") task_resume ;;
            "status") task_status ;;
            "complete") task_complete "$3" ;;
            *) echo "Usage: $0 task {resume|status|complete} [task_id]" ;;
        esac
        ;;
    "cleanup") cleanup_disabled ;;
    "analyze") analyze_project ;;
    "optimize") auto_optimize "$2" ;;
    "status") show_status ;;
    "reset") profile_reset ;;
    "help"|"-h"|"--help"|"") show_help ;;
    *) echo "Unknown command: $1. Use '$0 help' for usage." ;;
esac
