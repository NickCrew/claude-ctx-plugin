# This file contains the implementation code for modes view
# To be manually integrated into tui_textual.py

#  1. Add import for mode functions (line 34):
from .core.modes import mode_activate, mode_deactivate

# 2. Add ModeInfo dataclass (after RuleNode, around line 45):
@dataclass
class ModeInfo:
    """Represents a mode in the system."""
    name: str
    status: str  # "active" or "inactive"
    description: str
    path: Path

# 3. Add load_modes() method call in on_mount() (add after line 125):
        self.load_modes()

# 4. Add load_modes() method (add after _parse_agent_file, around line 220):
    def load_modes(self) -> None:
        """Load modes from the system."""
        try:
            modes = []
            claude_dir = _resolve_claude_dir()

            # Check active modes
            modes_dir = claude_dir / "modes"
            if modes_dir.is_dir():
                for path in _iter_md_files(modes_dir):
                    if _is_disabled(path):
                        continue
                    mode = self._parse_mode_file(path, "active")
                    if mode:
                        modes.append(mode)

            # Check inactive modes
            inactive_dirs = [
                claude_dir / "modes-disabled",
                modes_dir / "disabled" if modes_dir.is_dir() else None,
                modes_dir / "inactive" if modes_dir.is_dir() else None,
            ]

            for inactive_dir in inactive_dirs:
                if inactive_dir and inactive_dir.is_dir():
                    for path in _iter_md_files(inactive_dir):
                        mode = self._parse_mode_file(path, "inactive")
                        if mode:
                            modes.append(mode)

            # Sort by name
            modes.sort(key=lambda m: m.name.lower())

            self.modes = modes
            active_count = sum(1 for m in modes if m.status == "active")
            self.status_message = f"Loaded {len(modes)} modes ({active_count} active)"

        except Exception as e:
            self.status_message = f"Error loading modes: {e}"
            self.modes = []

    def _parse_mode_file(self, path: Path, status: str) -> Optional[ModeInfo]:
        """Parse a mode file and extract description."""
        try:
            content = path.read_text(encoding="utf-8")
            lines = content.split("\n")

            # Extract name from first # heading or filename
            name = path.stem.replace("_", " ").replace("-", " ")
            for line in lines[:10]:  # Check first 10 lines
                if line.startswith("# "):
                    name = line[2:].strip()
                    break

            # Extract description from "**Purpose**:" or second line
            description = ""
            for i, line in enumerate(lines[:20]):  # Check first 20 lines
                if "**Purpose**:" in line or "**purpose**:" in line.lower():
                    description = line.split(":", 1)[1].strip()
                    break
                elif line.strip() and not line.startswith("#") and i > 0:
                    description = line.strip()[:100]  # First 100 chars
                    if description:
                        break

            if not description:
                description = "No description available"

            return ModeInfo(
                name=name,
                status=status,
                description=description,
                path=path,
            )
        except Exception:
            return None

# 5. Add show_modes_view() method (add after show_agents_view, around line 283):
    def show_modes_view(self, table: DataTable) -> None:
        """Show modes table."""
        table.add_column("Name", key="name")
        table.add_column("Status", key="status")
        table.add_column("Description", key="description")

        if not hasattr(self, 'modes') or not self.modes:
            table.add_row("No modes found", "", "")
            return

        for mode in self.modes:
            status_text = "Active" if mode.status == "active" else "Inactive"
            table.add_row(
                mode.name,
                status_text,
                mode.description,
            )

# 6. Update update_view() to handle modes (add elif after line 258):
        elif self.current_view == "modes":
            self.show_modes_view(table)

# 7. Update action_toggle() for modes (add elif after agents block, around line 360):
        elif self.current_view == "modes":
            table = self.query_one(DataTable)
            if table.cursor_row is not None:
                row_key = table.get_row_at(table.cursor_row)
                if row_key and len(row_key) > 0:
                    mode_name = str(row_key[0])
                    mode = next((m for m in self.modes if m.name == mode_name), None)
                    if mode:
                        try:
                            # Use the file stem (slug) for activation/deactivation
                            mode_slug = mode.path.stem
                            if mode.status == "active":
                                exit_code, message = mode_deactivate(mode_slug)
                            else:
                                exit_code, message = mode_activate(mode_slug)

                            # Remove ANSI codes
                            import re
                            clean_message = re.sub(r"\x1b\[[0-9;]*m", "", message)
                            self.status_message = clean_message.split("\n")[0]

                            if exit_code == 0:
                                self.load_modes()
                                self.update_view()
                        except Exception as e:
                            self.status_message = f"Error: {e}"

# 8. Update action_refresh() for modes (add elif after agents block, around line 367):
        elif self.current_view == "modes":
            self.load_modes()
            self.update_view()
